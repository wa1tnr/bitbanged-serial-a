
AtmelStart.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000ef4  00004000  00004000  00004000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     0000000c  20000000  00004ef4  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bkupram      00000000  47000000  47000000  0001000c  2**0
                  CONTENTS
  3 .qspi         00000000  04000000  04000000  0001000c  2**0
                  CONTENTS
  4 .bss          00000038  2000000c  00004f00  0001000c  2**2
                  ALLOC
  5 .stack        0000c004  20000044  00004f38  0001000c  2**0
                  ALLOC
  6 .ARM.attributes 0000002e  00000000  00000000  0001000c  2**0
                  CONTENTS, READONLY
  7 .comment      0000007f  00000000  00000000  0001003a  2**0
                  CONTENTS, READONLY
  8 .debug_info   0000b9e3  00000000  00000000  000100b9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00001149  00000000  00000000  0001ba9c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000efe  00000000  00000000  0001cbe5  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 00000350  00000000  00000000  0001dae3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000004e8  00000000  00000000  0001de33  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  00002281  00000000  00000000  0001e31b  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_line   00003c36  00000000  00000000  0002059c  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_str    000d27a8  00000000  00000000  000241d2  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  0000093c  00000000  00000000  000f697c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00004000 <exception_table>:
    4000:	48 c0 00 20 01 43 00 00 fd 42 00 00 fd 42 00 00     H.. .C...B...B..
    4010:	fd 42 00 00 fd 42 00 00 fd 42 00 00 00 00 00 00     .B...B...B......
	...
    402c:	fd 42 00 00 fd 42 00 00 00 00 00 00 fd 42 00 00     .B...B.......B..
    403c:	fd 42 00 00 fd 42 00 00 fd 42 00 00 fd 42 00 00     .B...B...B...B..
    404c:	fd 42 00 00 fd 42 00 00 fd 42 00 00 fd 42 00 00     .B...B...B...B..
    405c:	fd 42 00 00 fd 42 00 00 fd 42 00 00 fd 42 00 00     .B...B...B...B..
    406c:	79 43 00 00 fd 42 00 00 fd 42 00 00 fd 42 00 00     yC...B...B...B..
    407c:	fd 42 00 00 fd 42 00 00 fd 42 00 00 fd 42 00 00     .B...B...B...B..
    408c:	fd 42 00 00 fd 42 00 00 fd 42 00 00 fd 42 00 00     .B...B...B...B..
    409c:	fd 42 00 00 fd 42 00 00 fd 42 00 00 fd 42 00 00     .B...B...B...B..
    40ac:	fd 42 00 00 fd 42 00 00 fd 42 00 00 fd 42 00 00     .B...B...B...B..
    40bc:	fd 42 00 00 fd 42 00 00 fd 42 00 00 fd 42 00 00     .B...B...B...B..
    40cc:	fd 42 00 00 fd 42 00 00 fd 42 00 00 fd 42 00 00     .B...B...B...B..
    40dc:	fd 42 00 00 fd 42 00 00 fd 42 00 00 fd 42 00 00     .B...B...B...B..
    40ec:	fd 42 00 00 00 00 00 00 a5 42 00 00 fd 42 00 00     .B.......B...B..
    40fc:	fd 42 00 00 fd 42 00 00 fd 42 00 00 fd 42 00 00     .B...B...B...B..
    410c:	fd 42 00 00 fd 42 00 00 fd 42 00 00 fd 42 00 00     .B...B...B...B..
    411c:	fd 42 00 00 fd 42 00 00 fd 42 00 00 fd 42 00 00     .B...B...B...B..
    412c:	fd 42 00 00 fd 42 00 00 fd 42 00 00 fd 42 00 00     .B...B...B...B..
    413c:	fd 42 00 00 fd 42 00 00 fd 42 00 00 fd 42 00 00     .B...B...B...B..
    414c:	fd 42 00 00 fd 42 00 00 fd 42 00 00 00 00 00 00     .B...B...B......
	...
    4180:	fd 42 00 00 fd 42 00 00 fd 42 00 00 fd 42 00 00     .B...B...B...B..
    4190:	00 00 00 00 fd 42 00 00 fd 42 00 00 fd 42 00 00     .....B...B...B..
    41a0:	fd 42 00 00 fd 42 00 00 fd 42 00 00 fd 42 00 00     .B...B...B...B..
    41b0:	fd 42 00 00 fd 42 00 00 fd 42 00 00 fd 42 00 00     .B...B...B...B..
    41c0:	fd 42 00 00 fd 42 00 00 fd 42 00 00 fd 42 00 00     .B...B...B...B..
    41d0:	fd 42 00 00 00 00 00 00 00 00 00 00 00 00 00 00     .B..............
	...
    41ec:	b1 43 00 00 c1 43 00 00 fd 42 00 00 fd 42 00 00     .C...C...B...B..
	...
    420c:	fd 42 00 00 fd 42 00 00 fd 42 00 00 fd 42 00 00     .B...B...B...B..
    421c:	fd 42 00 00 fd 42 00 00 fd 42 00 00 fd 42 00 00     .B...B...B...B..
    422c:	fd 42 00 00 fd 42 00 00 fd 42 00 00 fd 42 00 00     .B...B...B...B..
    423c:	fd 42 00 00 00 00 00 00 fd 42 00 00 fd 42 00 00     .B.......B...B..
    424c:	fd 42 00 00 fd 42 00 00 fd 42 00 00 fd 42 00 00     .B...B...B...B..
    425c:	fd 42 00 00 00 00 00 00                             .B......

00004264 <__do_global_dtors_aux>:
    4264:	b510      	push	{r4, lr}
    4266:	4c05      	ldr	r4, [pc, #20]	; (427c <__do_global_dtors_aux+0x18>)
    4268:	7823      	ldrb	r3, [r4, #0]
    426a:	b933      	cbnz	r3, 427a <__do_global_dtors_aux+0x16>
    426c:	4b04      	ldr	r3, [pc, #16]	; (4280 <__do_global_dtors_aux+0x1c>)
    426e:	b113      	cbz	r3, 4276 <__do_global_dtors_aux+0x12>
    4270:	4804      	ldr	r0, [pc, #16]	; (4284 <__do_global_dtors_aux+0x20>)
    4272:	f3af 8000 	nop.w
    4276:	2301      	movs	r3, #1
    4278:	7023      	strb	r3, [r4, #0]
    427a:	bd10      	pop	{r4, pc}
    427c:	2000000c 	.word	0x2000000c
    4280:	00000000 	.word	0x00000000
    4284:	00004ef4 	.word	0x00004ef4

00004288 <frame_dummy>:
    4288:	b508      	push	{r3, lr}
    428a:	4b03      	ldr	r3, [pc, #12]	; (4298 <frame_dummy+0x10>)
    428c:	b11b      	cbz	r3, 4296 <frame_dummy+0xe>
    428e:	4903      	ldr	r1, [pc, #12]	; (429c <frame_dummy+0x14>)
    4290:	4803      	ldr	r0, [pc, #12]	; (42a0 <frame_dummy+0x18>)
    4292:	f3af 8000 	nop.w
    4296:	bd08      	pop	{r3, pc}
    4298:	00000000 	.word	0x00000000
    429c:	20000010 	.word	0x20000010
    42a0:	00004ef4 	.word	0x00004ef4

000042a4 <RAMECC_Handler>:
	return tmp;
}

static inline hri_ramecc_intflag_reg_t hri_ramecc_read_INTFLAG_reg(const void *const hw)
{
	return ((Ramecc *)hw)->INTFLAG.reg;
    42a4:	4a0b      	ldr	r2, [pc, #44]	; (42d4 <RAMECC_Handler+0x30>)
    42a6:	7893      	ldrb	r3, [r2, #2]

/**
 * \internal RAMECC interrupt handler
 */
void RAMECC_Handler(void)
{
    42a8:	b082      	sub	sp, #8
    42aa:	b2db      	uxtb	r3, r3
	struct _ramecc_device *dev      = (struct _ramecc_device *)&device;
	volatile uint32_t      int_mask = hri_ramecc_read_INTFLAG_reg(RAMECC);
    42ac:	9301      	str	r3, [sp, #4]

	if (int_mask & RAMECC_INTFLAG_DUALE && dev->ramecc_cb.dual_bit_err) {
    42ae:	9b01      	ldr	r3, [sp, #4]
    42b0:	0799      	lsls	r1, r3, #30
    42b2:	d505      	bpl.n	42c0 <RAMECC_Handler+0x1c>
    42b4:	4b08      	ldr	r3, [pc, #32]	; (42d8 <RAMECC_Handler+0x34>)
    42b6:	681b      	ldr	r3, [r3, #0]
    42b8:	b113      	cbz	r3, 42c0 <RAMECC_Handler+0x1c>
	return tmp;
}

static inline hri_ramecc_erraddr_reg_t hri_ramecc_read_ERRADDR_reg(const void *const hw)
{
	return ((Ramecc *)hw)->ERRADDR.reg;
    42ba:	6850      	ldr	r0, [r2, #4]
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
	} else {
		return;
	}
}
    42bc:	b002      	add	sp, #8
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
    42be:	4718      	bx	r3
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
    42c0:	9b01      	ldr	r3, [sp, #4]
    42c2:	07db      	lsls	r3, r3, #31
    42c4:	d504      	bpl.n	42d0 <RAMECC_Handler+0x2c>
    42c6:	4b04      	ldr	r3, [pc, #16]	; (42d8 <RAMECC_Handler+0x34>)
    42c8:	685b      	ldr	r3, [r3, #4]
    42ca:	b10b      	cbz	r3, 42d0 <RAMECC_Handler+0x2c>
    42cc:	4a01      	ldr	r2, [pc, #4]	; (42d4 <RAMECC_Handler+0x30>)
    42ce:	e7f4      	b.n	42ba <RAMECC_Handler+0x16>
}
    42d0:	b002      	add	sp, #8
    42d2:	4770      	bx	lr
    42d4:	41020000 	.word	0x41020000
    42d8:	20000034 	.word	0x20000034

000042dc <SystemInit>:
 *         Initialize the System and update the SystemCoreClock variable.
 */
void SystemInit(void)
{
	// Keep the default device state after reset
	SystemCoreClock = __SYSTEM_CLOCK;
    42dc:	4b01      	ldr	r3, [pc, #4]	; (42e4 <SystemInit+0x8>)
    42de:	4a02      	ldr	r2, [pc, #8]	; (42e8 <SystemInit+0xc>)
    42e0:	601a      	str	r2, [r3, #0]
	return;
}
    42e2:	4770      	bx	lr
    42e4:	20000000 	.word	0x20000000
    42e8:	02dc6c00 	.word	0x02dc6c00

000042ec <SystemCoreClockUpdate>:
    42ec:	4b01      	ldr	r3, [pc, #4]	; (42f4 <SystemCoreClockUpdate+0x8>)
    42ee:	4a02      	ldr	r2, [pc, #8]	; (42f8 <SystemCoreClockUpdate+0xc>)
    42f0:	601a      	str	r2, [r3, #0]
    42f2:	4770      	bx	lr
    42f4:	20000000 	.word	0x20000000
    42f8:	02dc6c00 	.word	0x02dc6c00

000042fc <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
    42fc:	e7fe      	b.n	42fc <Dummy_Handler>
	...

00004300 <Reset_Handler>:
{
    4300:	b508      	push	{r3, lr}
	if (pSrc != pDest) {
    4302:	4a14      	ldr	r2, [pc, #80]	; (4354 <Reset_Handler+0x54>)
    4304:	4b14      	ldr	r3, [pc, #80]	; (4358 <Reset_Handler+0x58>)
    4306:	429a      	cmp	r2, r3
    4308:	d003      	beq.n	4312 <Reset_Handler+0x12>
		for (; pDest < &_erelocate;) {
    430a:	4914      	ldr	r1, [pc, #80]	; (435c <Reset_Handler+0x5c>)
    430c:	3a04      	subs	r2, #4
    430e:	428b      	cmp	r3, r1
    4310:	d318      	bcc.n	4344 <Reset_Handler+0x44>
{
    4312:	4b13      	ldr	r3, [pc, #76]	; (4360 <Reset_Handler+0x60>)
	for (pDest = &_szero; pDest < &_ezero;) {
    4314:	4a13      	ldr	r2, [pc, #76]	; (4364 <Reset_Handler+0x64>)
		*pDest++ = 0;
    4316:	2100      	movs	r1, #0
	for (pDest = &_szero; pDest < &_ezero;) {
    4318:	4293      	cmp	r3, r2
    431a:	d318      	bcc.n	434e <Reset_Handler+0x4e>
	SCB->VTOR = ((uint32_t)pSrc & SCB_VTOR_TBLOFF_Msk);
    431c:	4a12      	ldr	r2, [pc, #72]	; (4368 <Reset_Handler+0x68>)
    431e:	4b13      	ldr	r3, [pc, #76]	; (436c <Reset_Handler+0x6c>)
    4320:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
    4324:	609a      	str	r2, [r3, #8]
	SCB->CPACR |= (0xFu << 20);
    4326:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    432a:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
    432e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    4332:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    4336:	f3bf 8f6f 	isb	sy
	__libc_init_array();
    433a:	4b0d      	ldr	r3, [pc, #52]	; (4370 <Reset_Handler+0x70>)
    433c:	4798      	blx	r3
	main();
    433e:	4b0d      	ldr	r3, [pc, #52]	; (4374 <Reset_Handler+0x74>)
    4340:	4798      	blx	r3
    4342:	e7fe      	b.n	4342 <Reset_Handler+0x42>
			*pDest++ = *pSrc++;
    4344:	f852 0f04 	ldr.w	r0, [r2, #4]!
    4348:	f843 0b04 	str.w	r0, [r3], #4
    434c:	e7df      	b.n	430e <Reset_Handler+0xe>
		*pDest++ = 0;
    434e:	f843 1b04 	str.w	r1, [r3], #4
    4352:	e7e1      	b.n	4318 <Reset_Handler+0x18>
    4354:	00004ef4 	.word	0x00004ef4
    4358:	20000000 	.word	0x20000000
    435c:	2000000c 	.word	0x2000000c
    4360:	2000000c 	.word	0x2000000c
    4364:	20000044 	.word	0x20000044
    4368:	00004000 	.word	0x00004000
    436c:	e000ed00 	.word	0xe000ed00
    4370:	00004e8d 	.word	0x00004e8d
    4374:	00004d11 	.word	0x00004d11

00004378 <RTC_Handler>:
/**
 * \brief Rtc interrupt handler
 */
void RTC_Handler(void)
{
	_rtc_timer_interrupt_handler(_rtc_dev);
    4378:	4b07      	ldr	r3, [pc, #28]	; (4398 <RTC_Handler+0x20>)
{
    437a:	b510      	push	{r4, lr}
	_rtc_timer_interrupt_handler(_rtc_dev);
    437c:	681c      	ldr	r4, [r3, #0]
	uint16_t flag = hri_rtcmode0_read_INTFLAG_reg(dev->hw);
    437e:	68e3      	ldr	r3, [r4, #12]
	return tmp;
}

static inline hri_rtcmode0_intflag_reg_t hri_rtcmode0_read_INTFLAG_reg(const void *const hw)
{
	return ((Rtc *)hw)->MODE0.INTFLAG.reg;
    4380:	899b      	ldrh	r3, [r3, #12]
	if (flag & RTC_MODE0_INTFLAG_CMP0) {
    4382:	05db      	lsls	r3, r3, #23
    4384:	d507      	bpl.n	4396 <RTC_Handler+0x1e>
		if (dev->timer_cb.period_expired) {
    4386:	6823      	ldr	r3, [r4, #0]
    4388:	b10b      	cbz	r3, 438e <RTC_Handler+0x16>
			dev->timer_cb.period_expired(dev);
    438a:	4620      	mov	r0, r4
    438c:	4798      	blx	r3
		hri_rtcmode0_clear_interrupt_CMP0_bit(dev->hw);
    438e:	68e3      	ldr	r3, [r4, #12]
	((Rtc *)hw)->MODE0.INTFLAG.reg = RTC_MODE0_INTFLAG_CMP0;
    4390:	f44f 7280 	mov.w	r2, #256	; 0x100
    4394:	819a      	strh	r2, [r3, #12]
}
    4396:	bd10      	pop	{r4, pc}
    4398:	20000028 	.word	0x20000028

0000439c <tc_interrupt_handler>:
 *
 * \param[in] instance TC instance number
 */
static void tc_interrupt_handler(struct _timer_device *device)
{
	void *const hw = device->hw;
    439c:	68c2      	ldr	r2, [r0, #12]
	((Tc *)hw)->COUNT8.INTFLAG.reg = TC_INTFLAG_MC1;
}

static inline bool hri_tc_get_interrupt_OVF_bit(const void *const hw)
{
	return (((Tc *)hw)->COUNT8.INTFLAG.reg & TC_INTFLAG_OVF) >> TC_INTFLAG_OVF_Pos;
    439e:	7a91      	ldrb	r1, [r2, #10]

	if (hri_tc_get_interrupt_OVF_bit(hw)) {
    43a0:	07c9      	lsls	r1, r1, #31
    43a2:	d503      	bpl.n	43ac <tc_interrupt_handler+0x10>
}

static inline void hri_tc_clear_interrupt_OVF_bit(const void *const hw)
{
	((Tc *)hw)->COUNT8.INTFLAG.reg = TC_INTFLAG_OVF;
    43a4:	2101      	movs	r1, #1
    43a6:	7291      	strb	r1, [r2, #10]
		hri_tc_clear_interrupt_OVF_bit(hw);
		device->timer_cb.period_expired(device);
    43a8:	6803      	ldr	r3, [r0, #0]
    43aa:	4718      	bx	r3
	}
}
    43ac:	4770      	bx	lr
	...

000043b0 <TC0_Handler>:
/**
 * \brief TC interrupt handler
 */
void TC0_Handler(void)
{
	tc_interrupt_handler(_tc0_dev);
    43b0:	4b01      	ldr	r3, [pc, #4]	; (43b8 <TC0_Handler+0x8>)
    43b2:	6818      	ldr	r0, [r3, #0]
    43b4:	4b01      	ldr	r3, [pc, #4]	; (43bc <TC0_Handler+0xc>)
    43b6:	4718      	bx	r3
    43b8:	2000002c 	.word	0x2000002c
    43bc:	0000439d 	.word	0x0000439d

000043c0 <TC1_Handler>:
/**
 * \brief TC interrupt handler
 */
void TC1_Handler(void)
{
	tc_interrupt_handler(_tc1_dev);
    43c0:	4b01      	ldr	r3, [pc, #4]	; (43c8 <TC1_Handler+0x8>)
    43c2:	6858      	ldr	r0, [r3, #4]
    43c4:	4b01      	ldr	r3, [pc, #4]	; (43cc <TC1_Handler+0xc>)
    43c6:	4718      	bx	r3
    43c8:	2000002c 	.word	0x2000002c
    43cc:	0000439d 	.word	0x0000439d

000043d0 <pins_setup>:


// https://www.avrfreaks.net/forum/resolved-samd51-asf4start-clock-fail-debugger-hang

void pins_setup(void) {
    PORT->Group[0].DIRSET.reg  = (uint32_t)(1 << 21); // PA21 //  1 11 pinmode  // D11
    43d0:	4b05      	ldr	r3, [pc, #20]	; (43e8 <pins_setup+0x18>)
    43d2:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    43d6:	609a      	str	r2, [r3, #8]
    PORT->Group[0].DIRSET.reg  = (uint32_t)(1 << 23); // PA23 //  1 13 pinmode  // D13
    43d8:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
    43dc:	609a      	str	r2, [r3, #8]
    PORT->Group[1].DIRSET.reg  = (uint32_t)(1 << 16); // PB16 //  1 16 pinmode  // TX
    43de:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    43e2:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    // toggle: // PORT->Group[0].OUTTGL.reg = (uint32_t)(1 << 21); // PA21 // D11 toggle
}
    43e6:	4770      	bx	lr
    43e8:	41008000 	.word	0x41008000

000043ec <ClockInit120>:

void ClockInit120(void)
{
	// CONFIGURE FLASH MEMORY WAIT STATES
	//NVMCTRL->CTRLA.bit.RWS = 5; // 4WS allows up to 119 MHz, 5WS allows 120 MHz
	NVMCTRL->CTRLA.bit.AUTOWS = 1; // automatically determine the necessary wait states
    43ec:	4a29      	ldr	r2, [pc, #164]	; (4494 <ClockInit120+0xa8>)
    43ee:	8813      	ldrh	r3, [r2, #0]
    43f0:	f043 0304 	orr.w	r3, r3, #4
    43f4:	8013      	strh	r3, [r2, #0]

	// CONFIGURE EXTERNAL 32K CRYSTAL OSCILLATOR
	OSC32KCTRL->XOSC32K.bit.CGM = 1; // control gain mode: 1 = standard/XT 2 = high-speed/HS
    43f6:	4b28      	ldr	r3, [pc, #160]	; (4498 <ClockInit120+0xac>)
    43f8:	8a9a      	ldrh	r2, [r3, #20]
    43fa:	2101      	movs	r1, #1
    43fc:	f361 324e 	bfi	r2, r1, #13, #2
    4400:	829a      	strh	r2, [r3, #20]
	OSC32KCTRL->XOSC32K.bit.STARTUP = 0; // oscillator startup time, 0 = 62 ms
    4402:	8a9a      	ldrh	r2, [r3, #20]
    4404:	f36f 220a 	bfc	r2, #8, #3
    4408:	829a      	strh	r2, [r3, #20]
	OSC32KCTRL->XOSC32K.bit.ONDEMAND = 0; // always run
    440a:	8a9a      	ldrh	r2, [r3, #20]
    440c:	f36f 12c7 	bfc	r2, #7, #1
    4410:	829a      	strh	r2, [r3, #20]
	OSC32KCTRL->XOSC32K.bit.XTALEN = 1; // enable crystal driver circuit for XIN32/XOUT32 pins
    4412:	8a9a      	ldrh	r2, [r3, #20]
    4414:	f042 0204 	orr.w	r2, r2, #4
    4418:	829a      	strh	r2, [r3, #20]
	OSC32KCTRL->XOSC32K.bit.EN32K = 1; // enable the 32 kHz output clock
    441a:	8a9a      	ldrh	r2, [r3, #20]
    441c:	f042 0208 	orr.w	r2, r2, #8
    4420:	829a      	strh	r2, [r3, #20]
	OSC32KCTRL->XOSC32K.bit.ENABLE = 1;
    4422:	8a9a      	ldrh	r2, [r3, #20]
    4424:	f042 0202 	orr.w	r2, r2, #2
    4428:	829a      	strh	r2, [r3, #20]

	while (!OSC32KCTRL->STATUS.bit.XOSC32KRDY); // wait until crystal oscillator is stable and ready to be used as a clock source
    442a:	68da      	ldr	r2, [r3, #12]
    442c:	07d1      	lsls	r1, r2, #31
    442e:	d5fc      	bpl.n	442a <ClockInit120+0x3e>

	OSC32KCTRL->RTCCTRL.bit.RTCSEL = OSC32KCTRL_RTCCTRL_RTCSEL_XOSC32K_Val; // RTC should use the external 32K crystal
    4430:	7c1a      	ldrb	r2, [r3, #16]
    4432:	2105      	movs	r1, #5
    4434:	f361 0202 	bfi	r2, r1, #0, #3
    4438:	741a      	strb	r2, [r3, #16]

	// CONFIGURE MASTER CLOCK
	MCLK->CPUDIV.bit.DIV = 1; // use a divisor of 1 for the master clock
    443a:	4b18      	ldr	r3, [pc, #96]	; (449c <ClockInit120+0xb0>)
    443c:	2101      	movs	r1, #1
    443e:	7159      	strb	r1, [r3, #5]

	// CONFIGURE PLL0
	OSCCTRL->Dpll[0].DPLLCTRLB.bit.REFCLK = 1; // use OSC32K as the PLL reference clock
    4440:	f503 6300 	add.w	r3, r3, #2048	; 0x800
    4444:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    4446:	f361 1247 	bfi	r2, r1, #5, #3
    444a:	639a      	str	r2, [r3, #56]	; 0x38
#define      OSC_RATIO_AINSU 2746

        // try 1220 - 6.66 MHz on D11 and 40 MHz D4
        // try 1830 - 10.0 MHz on D11 
        // try 3661 - 20.0 MHz on D11 .. said to be a 120 MHz GCLK 0
	OSCCTRL->Dpll[0].DPLLRATIO.reg = (3<<16) + OSC_RATIO_AINSU ; // multiply OSC32K by 3662.11 to get 120 MHz (actual multiplier is LDR + 1 + LDRFRAC/32)
    444c:	4a14      	ldr	r2, [pc, #80]	; (44a0 <ClockInit120+0xb4>)
    444e:	635a      	str	r2, [r3, #52]	; 0x34

	// errata: When using a low-frequency input clock on FDPLLn, several FDPLL unlocks may occur while the output
	// frequency is stable. Workaround: when using a low-frequency input clock on FDPLLn, enable the lock bypass
	// feature to avoid FDPLL unlocks.
	OSCCTRL->Dpll[0].DPLLCTRLB.bit.LBYPASS = 1; // CLK_DPLL0 output clock is always on, and not dependent on frequency lock
    4450:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    4452:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
    4456:	639a      	str	r2, [r3, #56]	; 0x38
	OSCCTRL->Dpll[0].DPLLCTRLA.bit.ONDEMAND = 0; // always run
    4458:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
    445c:	f36f 12c7 	bfc	r2, #7, #1
    4460:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
	OSCCTRL->Dpll[0].DPLLCTRLA.bit.ENABLE = 1;
    4464:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
    4468:	f042 0202 	orr.w	r2, r2, #2
    446c:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30

	while (!OSCCTRL->Dpll[0].DPLLSTATUS.bit.LOCK) ; // no point in checking DPLLSTATUS.bit.CLKRDY, because LBYPASS is enabled
    4470:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    4472:	07d2      	lsls	r2, r2, #31
    4474:	d5fc      	bpl.n	4470 <ClockInit120+0x84>

	// CONFIGURE CLOCK GENERATOR 0
	GCLK->GENCTRL[0].bit.SRC = 7; // use PLL0 as the input
    4476:	4b0b      	ldr	r3, [pc, #44]	; (44a4 <ClockInit120+0xb8>)
    4478:	6a1a      	ldr	r2, [r3, #32]
    447a:	2107      	movs	r1, #7
    447c:	f361 0203 	bfi	r2, r1, #0, #4
    4480:	621a      	str	r2, [r3, #32]
	GCLK->GENCTRL[0].bit.DIV = 1; // divisor 1 for the input clock from the PLL
    4482:	6a1a      	ldr	r2, [r3, #32]
    4484:	f2c0 0201 	movt	r2, #1
    4488:	621a      	str	r2, [r3, #32]
	GCLK->GENCTRL[0].bit.GENEN = 1;
    448a:	6a1a      	ldr	r2, [r3, #32]
    448c:	f442 7280 	orr.w	r2, r2, #256	; 0x100
    4490:	621a      	str	r2, [r3, #32]

	// do peripheral clock initialization here...
}
    4492:	4770      	bx	lr
    4494:	41004000 	.word	0x41004000
    4498:	40001400 	.word	0x40001400
    449c:	40000800 	.word	0x40000800
    44a0:	00030aba 	.word	0x00030aba
    44a4:	40001c00 	.word	0x40001c00

000044a8 <setup_PA14_as_GCLK_IO>:

void setup_PA14_as_GCLK_IO(void) {

    // configure PA14 (board D4) as GCLK_IO[0] output of main clock generator,
    // to confirm 120 MHz operation
    PORT->Group[GPIO_PORTA].DIRSET.reg = (1 << 14); // set pin as output
    44a8:	4b0b      	ldr	r3, [pc, #44]	; (44d8 <setup_PA14_as_GCLK_IO+0x30>)
    44aa:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    44ae:	609a      	str	r2, [r3, #8]
    PORT->Group[GPIO_PORTA].PINCFG[14].bit.PMUXEN = 1; // enable the peripheral mux for this pin
    44b0:	f893 204e 	ldrb.w	r2, [r3, #78]	; 0x4e
    44b4:	f042 0201 	orr.w	r2, r2, #1
    44b8:	f883 204e 	strb.w	r2, [r3, #78]	; 0x4e
    PORT->Group[GPIO_PORTA].PMUX[(14>>1)].bit.PMUXE = MUX_PA14M_GCLK_IO0; // select the GCLK_IO0 peripheral function
    44bc:	f893 2037 	ldrb.w	r2, [r3, #55]	; 0x37
    44c0:	210c      	movs	r1, #12
    44c2:	f361 0203 	bfi	r2, r1, #0, #4
    44c6:	f883 2037 	strb.w	r2, [r3, #55]	; 0x37
    GCLK->GENCTRL[0].bit.OE = 1; // enable output from clock generator 0
    44ca:	4a04      	ldr	r2, [pc, #16]	; (44dc <setup_PA14_as_GCLK_IO+0x34>)
    44cc:	6a13      	ldr	r3, [r2, #32]
    44ce:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
    44d2:	6213      	str	r3, [r2, #32]
}
    44d4:	4770      	bx	lr
    44d6:	bf00      	nop
    44d8:	41008000 	.word	0x41008000
    44dc:	40001c00 	.word	0x40001c00

000044e0 <pip_space>:
// see a lot of QQQ with 137 #define SECU 137

// SECU 141 is on the money for 38400 bps  09 Aug 23:15 UTC
#define SECU 141

void pip_space(void) {
    44e0:	b082      	sub	sp, #8
// no gap between successive 'pulses' of the same value (GND or 3.3)
// so you just turn on (or off) the pin, and allow a timer to expire
// that has counted out the time interval for that many pulses (of
// 26 uSec duration, per, or thereabouts).

    for (volatile int j = SECU; j>0; j--) {
    44e2:	238d      	movs	r3, #141	; 0x8d
    44e4:	9301      	str	r3, [sp, #4]
    44e6:	9b01      	ldr	r3, [sp, #4]
    44e8:	2b00      	cmp	r3, #0
    44ea:	dc01      	bgt.n	44f0 <pip_space+0x10>
    }
}
    44ec:	b002      	add	sp, #8
    44ee:	4770      	bx	lr
    for (volatile int j = SECU; j>0; j--) {
    44f0:	9b01      	ldr	r3, [sp, #4]
    44f2:	3b01      	subs	r3, #1
    44f4:	e7f6      	b.n	44e4 <pip_space+0x4>
	...

000044f8 <send_vy_nothing>:


void send_vy_nothing(void) { // time gap
    44f8:	b507      	push	{r0, r1, r2, lr}
    for (volatile int p=35;p>0; p--) {
    44fa:	2323      	movs	r3, #35	; 0x23
        pip_space(); // delay 26 uSec
    44fc:	4a06      	ldr	r2, [pc, #24]	; (4518 <send_vy_nothing+0x20>)
    for (volatile int p=35;p>0; p--) {
    44fe:	9301      	str	r3, [sp, #4]
    4500:	9b01      	ldr	r3, [sp, #4]
    4502:	2b00      	cmp	r3, #0
    4504:	dc02      	bgt.n	450c <send_vy_nothing+0x14>
    }
}
    4506:	b003      	add	sp, #12
    4508:	f85d fb04 	ldr.w	pc, [sp], #4
        pip_space(); // delay 26 uSec
    450c:	4790      	blx	r2
    for (volatile int p=35;p>0; p--) {
    450e:	9b01      	ldr	r3, [sp, #4]
    4510:	3b01      	subs	r3, #1
    4512:	9301      	str	r3, [sp, #4]
    4514:	e7f4      	b.n	4500 <send_vy_nothing+0x8>
    4516:	bf00      	nop
    4518:	000044e1 	.word	0x000044e1

0000451c <send_sm_nothing>:

void send_sm_nothing(void) { // time gap
    451c:	b507      	push	{r0, r1, r2, lr}
    for (volatile int p=335;p>0; p--) {
    451e:	f240 134f 	movw	r3, #335	; 0x14f
        pip_space(); // delay 26 uSec
    4522:	4a06      	ldr	r2, [pc, #24]	; (453c <send_sm_nothing+0x20>)
    for (volatile int p=335;p>0; p--) {
    4524:	9301      	str	r3, [sp, #4]
    4526:	9b01      	ldr	r3, [sp, #4]
    4528:	2b00      	cmp	r3, #0
    452a:	dc02      	bgt.n	4532 <send_sm_nothing+0x16>
    }
}
    452c:	b003      	add	sp, #12
    452e:	f85d fb04 	ldr.w	pc, [sp], #4
        pip_space(); // delay 26 uSec
    4532:	4790      	blx	r2
    for (volatile int p=335;p>0; p--) {
    4534:	9b01      	ldr	r3, [sp, #4]
    4536:	3b01      	subs	r3, #1
    4538:	9301      	str	r3, [sp, #4]
    453a:	e7f4      	b.n	4526 <send_sm_nothing+0xa>
    453c:	000044e1 	.word	0x000044e1

00004540 <send_nothing>:

void send_nothing(void) { // time gap
    4540:	b507      	push	{r0, r1, r2, lr}
    for (volatile int p=3355;p>0; p--) {
    4542:	f640 531b 	movw	r3, #3355	; 0xd1b
        pip_space(); // delay 26 uSec
    4546:	4a06      	ldr	r2, [pc, #24]	; (4560 <send_nothing+0x20>)
    for (volatile int p=3355;p>0; p--) {
    4548:	9301      	str	r3, [sp, #4]
    454a:	9b01      	ldr	r3, [sp, #4]
    454c:	2b00      	cmp	r3, #0
    454e:	dc02      	bgt.n	4556 <send_nothing+0x16>
    }
}
    4550:	b003      	add	sp, #12
    4552:	f85d fb04 	ldr.w	pc, [sp], #4
        pip_space(); // delay 26 uSec
    4556:	4790      	blx	r2
    for (volatile int p=3355;p>0; p--) {
    4558:	9b01      	ldr	r3, [sp, #4]
    455a:	3b01      	subs	r3, #1
    455c:	9301      	str	r3, [sp, #4]
    455e:	e7f4      	b.n	454a <send_nothing+0xa>
    4560:	000044e1 	.word	0x000044e1

00004564 <common_end>:

void common_end(void) {

    // post-amble hi hi

    PORT->Group[1].OUTCLR.reg = (uint32_t)(1 << 16); // PB16 //  0 16 pinwrite
    4564:	4a09      	ldr	r2, [pc, #36]	; (458c <common_end+0x28>)
    pip_space(); // delay 26 uSec
    4566:	490a      	ldr	r1, [pc, #40]	; (4590 <common_end+0x2c>)
    PORT->Group[1].OUTCLR.reg = (uint32_t)(1 << 16); // PB16 //  0 16 pinwrite
    4568:	f44f 3380 	mov.w	r3, #65536	; 0x10000
void common_end(void) {
    456c:	b510      	push	{r4, lr}
    PORT->Group[1].OUTCLR.reg = (uint32_t)(1 << 16); // PB16 //  0 16 pinwrite
    456e:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
    pip_space(); // delay 26 uSec
    4572:	4788      	blx	r1
    PORT->Group[1].OUTSET.reg |= (uint32_t)(1 << 16); // PB16 //  1 16 pinwrite
    4574:	f8d2 3098 	ldr.w	r3, [r2, #152]	; 0x98
    4578:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    457c:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
    // now a very wide space
    pip_space(); // delay 26 uSec
    4580:	4788      	blx	r1
    send_vy_nothing(); // // time gap
    4582:	4b04      	ldr	r3, [pc, #16]	; (4594 <common_end+0x30>)
    // send_nothing(); // guard time
}
    4584:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    send_vy_nothing(); // // time gap
    4588:	4718      	bx	r3
    458a:	bf00      	nop
    458c:	41008000 	.word	0x41008000
    4590:	000044e1 	.word	0x000044e1
    4594:	000044f9 	.word	0x000044f9

00004598 <bit_CLR>:

void bit_CLR(void) { // send the bit cleared - ground the GPIO pin
    PORT->Group[1].OUTCLR.reg = (uint32_t)(1 << 16); // PB16 //  0 16 pinwrite
    4598:	4b03      	ldr	r3, [pc, #12]	; (45a8 <bit_CLR+0x10>)
    459a:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    459e:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    pip_space(); // delay 26 uSec
    45a2:	4b02      	ldr	r3, [pc, #8]	; (45ac <bit_CLR+0x14>)
    45a4:	4718      	bx	r3
    45a6:	bf00      	nop
    45a8:	41008000 	.word	0x41008000
    45ac:	000044e1 	.word	0x000044e1

000045b0 <bit_SET>:
}
void bit_SET(void) { // send the bit set - raise the GPIO pin to 3.3 VDC
    PORT->Group[1].OUTSET.reg |= (uint32_t)(1 << 16); // PB16 //  1 16 pinwrite
    45b0:	4a04      	ldr	r2, [pc, #16]	; (45c4 <bit_SET+0x14>)
    45b2:	f8d2 3098 	ldr.w	r3, [r2, #152]	; 0x98
    45b6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    45ba:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
    pip_space(); // delay 26 uSec
    45be:	4b02      	ldr	r3, [pc, #8]	; (45c8 <bit_SET+0x18>)
    45c0:	4718      	bx	r3
    45c2:	bf00      	nop
    45c4:	41008000 	.word	0x41008000
    45c8:	000044e1 	.word	0x000044e1

000045cc <send_preamble>:
}


void send_preamble(void) {
    45cc:	b510      	push	{r4, lr}
    // preamble

    // send_nothing(); // guard time
    // send_sm_nothing(); // // time gap
    send_vy_nothing(); // // time gap
    45ce:	4b04      	ldr	r3, [pc, #16]	; (45e0 <send_preamble+0x14>)
    45d0:	4798      	blx	r3
    pip_space(); // delay 26 uSec
    45d2:	4b04      	ldr	r3, [pc, #16]	; (45e4 <send_preamble+0x18>)
    45d4:	4798      	blx	r3
    bit_CLR();
    45d6:	4b04      	ldr	r3, [pc, #16]	; (45e8 <send_preamble+0x1c>)
    // preamble ends.
}
    45d8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    bit_CLR();
    45dc:	4718      	bx	r3
    45de:	bf00      	nop
    45e0:	000044f9 	.word	0x000044f9
    45e4:	000044e1 	.word	0x000044e1
    45e8:	00004599 	.word	0x00004599

000045ec <send_bravo>:
}


// ###bookmark
// ###bookmark
void send_bravo(void) { // 01 0000 1
    45ec:	b510      	push	{r4, lr}

    send_preamble();
    45ee:	4b07      	ldr	r3, [pc, #28]	; (460c <send_bravo+0x20>)
    45f0:	4798      	blx	r3
    bit_CLR(); bit_SET();
    45f2:	4907      	ldr	r1, [pc, #28]	; (4610 <send_bravo+0x24>)
    45f4:	4788      	blx	r1
    45f6:	4807      	ldr	r0, [pc, #28]	; (4614 <send_bravo+0x28>)
    45f8:	4780      	blx	r0
    bit_CLR(); bit_CLR(); bit_CLR(); bit_CLR();
    45fa:	4788      	blx	r1
    45fc:	4788      	blx	r1
    45fe:	4788      	blx	r1
    4600:	4788      	blx	r1
    bit_SET();
    4602:	4780      	blx	r0
    common_end();
    4604:	4b04      	ldr	r3, [pc, #16]	; (4618 <send_bravo+0x2c>)
}
    4606:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    common_end();
    460a:	4718      	bx	r3
    460c:	000045cd 	.word	0x000045cd
    4610:	00004599 	.word	0x00004599
    4614:	000045b1 	.word	0x000045b1
    4618:	00004565 	.word	0x00004565

0000461c <send_foxtrot>:

void send_foxtrot(void) { // 01 1000 1
    461c:	b510      	push	{r4, lr}

    send_preamble();
    461e:	4b07      	ldr	r3, [pc, #28]	; (463c <send_foxtrot+0x20>)
    4620:	4798      	blx	r3
    bit_CLR(); bit_SET();
    4622:	4907      	ldr	r1, [pc, #28]	; (4640 <send_foxtrot+0x24>)
    4624:	4788      	blx	r1
    4626:	4807      	ldr	r0, [pc, #28]	; (4644 <send_foxtrot+0x28>)
    4628:	4780      	blx	r0
    bit_SET();
    462a:	4780      	blx	r0
    bit_CLR(); bit_CLR(); bit_CLR();
    462c:	4788      	blx	r1
    462e:	4788      	blx	r1
    4630:	4788      	blx	r1
    bit_SET();
    4632:	4780      	blx	r0
    common_end();
    4634:	4b04      	ldr	r3, [pc, #16]	; (4648 <send_foxtrot+0x2c>)
}
    4636:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    common_end();
    463a:	4718      	bx	r3
    463c:	000045cd 	.word	0x000045cd
    4640:	00004599 	.word	0x00004599
    4644:	000045b1 	.word	0x000045b1
    4648:	00004565 	.word	0x00004565

0000464c <send_delta>:

void send_delta(void) { // 00 1000 1
    464c:	b510      	push	{r4, lr}

    send_preamble();
    464e:	4b07      	ldr	r3, [pc, #28]	; (466c <send_delta+0x20>)
    4650:	4798      	blx	r3
    bit_CLR(); bit_CLR();
    4652:	4907      	ldr	r1, [pc, #28]	; (4670 <send_delta+0x24>)
    4654:	4788      	blx	r1
    4656:	4788      	blx	r1
    bit_SET();
    4658:	4806      	ldr	r0, [pc, #24]	; (4674 <send_delta+0x28>)
    465a:	4780      	blx	r0
    bit_CLR(); bit_CLR(); bit_CLR();
    465c:	4788      	blx	r1
    465e:	4788      	blx	r1
    4660:	4788      	blx	r1
    bit_SET();
    4662:	4780      	blx	r0
    common_end();
    4664:	4b04      	ldr	r3, [pc, #16]	; (4678 <send_delta+0x2c>)
}
    4666:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    common_end();
    466a:	4718      	bx	r3
    466c:	000045cd 	.word	0x000045cd
    4670:	00004599 	.word	0x00004599
    4674:	000045b1 	.word	0x000045b1
    4678:	00004565 	.word	0x00004565

0000467c <send_echo>:

void send_echo(void) { // 01 1000 1
    467c:	b510      	push	{r4, lr}
   //  new            echo:     101 000 1

    send_preamble();
    467e:	4b07      	ldr	r3, [pc, #28]	; (469c <send_echo+0x20>)
    4680:	4798      	blx	r3
    bit_SET(); bit_CLR(); bit_SET();
    4682:	4807      	ldr	r0, [pc, #28]	; (46a0 <send_echo+0x24>)
    4684:	4780      	blx	r0
    4686:	4907      	ldr	r1, [pc, #28]	; (46a4 <send_echo+0x28>)
    4688:	4788      	blx	r1
    468a:	4780      	blx	r0
    bit_CLR(); bit_CLR(); bit_CLR();
    468c:	4788      	blx	r1
    468e:	4788      	blx	r1
    4690:	4788      	blx	r1
    bit_SET();
    4692:	4780      	blx	r0
    common_end();
    4694:	4b04      	ldr	r3, [pc, #16]	; (46a8 <send_echo+0x2c>)
}
    4696:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    common_end();
    469a:	4718      	bx	r3
    469c:	000045cd 	.word	0x000045cd
    46a0:	000045b1 	.word	0x000045b1
    46a4:	00004599 	.word	0x00004599
    46a8:	00004565 	.word	0x00004565

000046ac <send_charley>:

void send_charley(void) { // 11 0000 1
    46ac:	b510      	push	{r4, lr}
    send_preamble();
    46ae:	4b07      	ldr	r3, [pc, #28]	; (46cc <send_charley+0x20>)
    46b0:	4798      	blx	r3
    bit_SET(); bit_SET();
    46b2:	4807      	ldr	r0, [pc, #28]	; (46d0 <send_charley+0x24>)
    46b4:	4780      	blx	r0
    46b6:	4780      	blx	r0
    bit_CLR(); bit_CLR(); bit_CLR(); bit_CLR(); 
    46b8:	4906      	ldr	r1, [pc, #24]	; (46d4 <send_charley+0x28>)
    46ba:	4788      	blx	r1
    46bc:	4788      	blx	r1
    46be:	4788      	blx	r1
    46c0:	4788      	blx	r1
    bit_SET();
    46c2:	4780      	blx	r0
    common_end();
    46c4:	4b04      	ldr	r3, [pc, #16]	; (46d8 <send_charley+0x2c>)
}
    46c6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    common_end();
    46ca:	4718      	bx	r3
    46cc:	000045cd 	.word	0x000045cd
    46d0:	000045b1 	.word	0x000045b1
    46d4:	00004599 	.word	0x00004599
    46d8:	00004565 	.word	0x00004565

000046dc <send_golf>:


// ###bookmark 
// ###bookmark

void send_golf(void) { // 111 000 1
    46dc:	b510      	push	{r4, lr}

    send_preamble();
    46de:	4b07      	ldr	r3, [pc, #28]	; (46fc <send_golf+0x20>)
    46e0:	4798      	blx	r3
    bit_SET(); bit_SET(); bit_SET();
    46e2:	4907      	ldr	r1, [pc, #28]	; (4700 <send_golf+0x24>)
    46e4:	4788      	blx	r1
    46e6:	4788      	blx	r1
    46e8:	4788      	blx	r1
    bit_CLR(); bit_CLR(); bit_CLR();
    46ea:	4806      	ldr	r0, [pc, #24]	; (4704 <send_golf+0x28>)
    46ec:	4780      	blx	r0
    46ee:	4780      	blx	r0
    46f0:	4780      	blx	r0
    bit_SET();
    46f2:	4788      	blx	r1
    common_end();
    46f4:	4b04      	ldr	r3, [pc, #16]	; (4708 <send_golf+0x2c>)
}
    46f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    common_end();
    46fa:	4718      	bx	r3
    46fc:	000045cd 	.word	0x000045cd
    4700:	000045b1 	.word	0x000045b1
    4704:	00004599 	.word	0x00004599
    4708:	00004565 	.word	0x00004565

0000470c <send_three>:


void send_three(void) { // zero then double alt  11 00 11 0
    470c:	b510      	push	{r4, lr}
    send_preamble();
    470e:	4b07      	ldr	r3, [pc, #28]	; (472c <send_three+0x20>)
    4710:	4798      	blx	r3
    bit_SET(); bit_SET();
    4712:	4907      	ldr	r1, [pc, #28]	; (4730 <send_three+0x24>)
    4714:	4788      	blx	r1
    4716:	4788      	blx	r1
    bit_CLR(); bit_CLR();
    4718:	4806      	ldr	r0, [pc, #24]	; (4734 <send_three+0x28>)
    471a:	4780      	blx	r0
    471c:	4780      	blx	r0
    bit_SET(); bit_SET();
    471e:	4788      	blx	r1
    4720:	4788      	blx	r1
    bit_CLR();
    4722:	4780      	blx	r0
    common_end();
    4724:	4b04      	ldr	r3, [pc, #16]	; (4738 <send_three+0x2c>)
}
    4726:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    common_end();
    472a:	4718      	bx	r3
    472c:	000045cd 	.word	0x000045cd
    4730:	000045b1 	.word	0x000045b1
    4734:	00004599 	.word	0x00004599
    4738:	00004565 	.word	0x00004565

0000473c <send_two>:

void send_two(void) { // like three: 01 00 11 0
    473c:	b510      	push	{r4, lr}
    send_preamble();
    473e:	4b07      	ldr	r3, [pc, #28]	; (475c <send_two+0x20>)
    4740:	4798      	blx	r3
    bit_CLR(); bit_SET();
    4742:	4907      	ldr	r1, [pc, #28]	; (4760 <send_two+0x24>)
    4744:	4788      	blx	r1
    4746:	4807      	ldr	r0, [pc, #28]	; (4764 <send_two+0x28>)
    4748:	4780      	blx	r0
    bit_CLR(); bit_CLR();
    474a:	4788      	blx	r1
    474c:	4788      	blx	r1
    bit_SET(); bit_SET();
    474e:	4780      	blx	r0
    4750:	4780      	blx	r0
    bit_CLR();
    4752:	4788      	blx	r1
    common_end();
    4754:	4b04      	ldr	r3, [pc, #16]	; (4768 <send_two+0x2c>)
}
    4756:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    common_end();
    475a:	4718      	bx	r3
    475c:	000045cd 	.word	0x000045cd
    4760:	00004599 	.word	0x00004599
    4764:	000045b1 	.word	0x000045b1
    4768:	00004565 	.word	0x00004565

0000476c <send_lf>:


void send_lf(void) { // 0101000
    476c:	b510      	push	{r4, lr}
    send_preamble();
    476e:	4b07      	ldr	r3, [pc, #28]	; (478c <send_lf+0x20>)
    4770:	4798      	blx	r3
    bit_CLR(); bit_SET();
    4772:	4907      	ldr	r1, [pc, #28]	; (4790 <send_lf+0x24>)
    4774:	4788      	blx	r1
    4776:	4807      	ldr	r0, [pc, #28]	; (4794 <send_lf+0x28>)
    4778:	4780      	blx	r0
    bit_CLR(); bit_SET();
    477a:	4788      	blx	r1
    477c:	4780      	blx	r0
    bit_CLR(); bit_CLR(); bit_CLR();
    477e:	4788      	blx	r1
    4780:	4788      	blx	r1
    4782:	4788      	blx	r1
    common_end();
    4784:	4b04      	ldr	r3, [pc, #16]	; (4798 <send_lf+0x2c>)
}
    4786:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    common_end();
    478a:	4718      	bx	r3
    478c:	000045cd 	.word	0x000045cd
    4790:	00004599 	.word	0x00004599
    4794:	000045b1 	.word	0x000045b1
    4798:	00004565 	.word	0x00004565

0000479c <send_cr>:

void send_cr(void) { // 1011000
    479c:	b510      	push	{r4, lr}
    send_preamble();
    479e:	4b07      	ldr	r3, [pc, #28]	; (47bc <send_cr+0x20>)
    47a0:	4798      	blx	r3
    bit_SET();
    47a2:	4807      	ldr	r0, [pc, #28]	; (47c0 <send_cr+0x24>)
    47a4:	4780      	blx	r0
    bit_CLR();
    47a6:	4907      	ldr	r1, [pc, #28]	; (47c4 <send_cr+0x28>)
    47a8:	4788      	blx	r1
    bit_SET(); bit_SET();
    47aa:	4780      	blx	r0
    47ac:	4780      	blx	r0
    bit_CLR(); bit_CLR(); bit_CLR();
    47ae:	4788      	blx	r1
    47b0:	4788      	blx	r1
    47b2:	4788      	blx	r1
    common_end();
    47b4:	4b04      	ldr	r3, [pc, #16]	; (47c8 <send_cr+0x2c>)
}
    47b6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    common_end();
    47ba:	4718      	bx	r3
    47bc:	000045cd 	.word	0x000045cd
    47c0:	000045b1 	.word	0x000045b1
    47c4:	00004599 	.word	0x00004599
    47c8:	00004565 	.word	0x00004565

000047cc <send_crlf>:

void send_crlf(void) {
    47cc:	b510      	push	{r4, lr}
    send_cr();
    47ce:	4b03      	ldr	r3, [pc, #12]	; (47dc <send_crlf+0x10>)
    47d0:	4798      	blx	r3
    send_lf();
    47d2:	4b03      	ldr	r3, [pc, #12]	; (47e0 <send_crlf+0x14>)
}
    47d4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    send_lf();
    47d8:	4718      	bx	r3
    47da:	bf00      	nop
    47dc:	0000479d 	.word	0x0000479d
    47e0:	0000476d 	.word	0x0000476d

000047e4 <send_space>:

void send_space(void) { // ascii 32 0x20 delimiter
    47e4:	b510      	push	{r4, lr}
    // preamble

    send_nothing(); // guard time
    47e6:	4b09      	ldr	r3, [pc, #36]	; (480c <send_space+0x28>)
    47e8:	4798      	blx	r3
    pip_space(); // delay 26 uSec
    47ea:	4b09      	ldr	r3, [pc, #36]	; (4810 <send_space+0x2c>)
    47ec:	4798      	blx	r3

    bit_CLR();
    47ee:	4909      	ldr	r1, [pc, #36]	; (4814 <send_space+0x30>)
    47f0:	4788      	blx	r1

    // preamble ends.


    // send 2^0 bit:
    bit_CLR();
    47f2:	4788      	blx	r1

    // send 2^1 bit:
    bit_CLR();
    47f4:	4788      	blx	r1

    // send 2^2 bit:
    bit_CLR();
    47f6:	4788      	blx	r1

    // send 2^3 bit:
    bit_CLR();
    47f8:	4788      	blx	r1

    // send 2^4 bit:
    bit_CLR();
    47fa:	4788      	blx	r1

    // send 2^5 bit:
    bit_SET();
    47fc:	4b06      	ldr	r3, [pc, #24]	; (4818 <send_space+0x34>)
    47fe:	4798      	blx	r3

    // send 2^6 bit:
    bit_CLR();
    4800:	4788      	blx	r1

    // post-amble hi hi

    common_end();
    4802:	4b06      	ldr	r3, [pc, #24]	; (481c <send_space+0x38>)
}
    4804:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    common_end();
    4808:	4718      	bx	r3
    480a:	bf00      	nop
    480c:	00004541 	.word	0x00004541
    4810:	000044e1 	.word	0x000044e1
    4814:	00004599 	.word	0x00004599
    4818:	000045b1 	.word	0x000045b1
    481c:	00004565 	.word	0x00004565

00004820 <send_gap>:


void send_gap(void) { 
    4820:	b510      	push	{r4, lr}
    send_sm_nothing();
    4822:	4b03      	ldr	r3, [pc, #12]	; (4830 <send_gap+0x10>)
    4824:	4798      	blx	r3
    send_space();    // character delimiter: whitespace
    4826:	4b03      	ldr	r3, [pc, #12]	; (4834 <send_gap+0x14>)
}
    4828:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    send_space();    // character delimiter: whitespace
    482c:	4718      	bx	r3
    482e:	bf00      	nop
    4830:	0000451d 	.word	0x0000451d
    4834:	000047e5 	.word	0x000047e5

00004838 <send_gapp>:

void send_gapp(void) { // send the gap between character groups
    4838:	b510      	push	{r4, lr}
    send_nothing();  // large inter-char time delay
    483a:	4b03      	ldr	r3, [pc, #12]	; (4848 <send_gapp+0x10>)
    483c:	4798      	blx	r3
    send_space();    // character delimiter: whitespace
    483e:	4b03      	ldr	r3, [pc, #12]	; (484c <send_gapp+0x14>)
}
    4840:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    send_space();    // character delimiter: whitespace
    4844:	4718      	bx	r3
    4846:	bf00      	nop
    4848:	00004541 	.word	0x00004541
    484c:	000047e5 	.word	0x000047e5

00004850 <send_gapspace>:


void send_gapspace(void) {
    4850:	b510      	push	{r4, lr}
    send_gap();
    4852:	4803      	ldr	r0, [pc, #12]	; (4860 <send_gapspace+0x10>)
    4854:	4780      	blx	r0
    send_space();
    4856:	4b03      	ldr	r3, [pc, #12]	; (4864 <send_gapspace+0x14>)
    4858:	4798      	blx	r3
    send_gap();
}
    485a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    send_gap();
    485e:	4700      	bx	r0
    4860:	00004821 	.word	0x00004821
    4864:	000047e5 	.word	0x000047e5

00004868 <send_zero>:
    send_gapspace();
    send_lf();
    send_gapspace();
}

void send_zero(void) { // 0000110
    4868:	b510      	push	{r4, lr}
    send_preamble();
    486a:	4b07      	ldr	r3, [pc, #28]	; (4888 <send_zero+0x20>)
    486c:	4798      	blx	r3
    bit_CLR(); bit_CLR(); bit_CLR(); bit_CLR();
    486e:	4907      	ldr	r1, [pc, #28]	; (488c <send_zero+0x24>)
    4870:	4788      	blx	r1
    4872:	4788      	blx	r1
    4874:	4788      	blx	r1
    4876:	4788      	blx	r1
    bit_SET(); bit_SET();
    4878:	4805      	ldr	r0, [pc, #20]	; (4890 <send_zero+0x28>)
    487a:	4780      	blx	r0
    487c:	4780      	blx	r0
    bit_CLR();
    487e:	4788      	blx	r1
    common_end();
    4880:	4b04      	ldr	r3, [pc, #16]	; (4894 <send_zero+0x2c>)
}
    4882:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    common_end();
    4886:	4718      	bx	r3
    4888:	000045cd 	.word	0x000045cd
    488c:	00004599 	.word	0x00004599
    4890:	000045b1 	.word	0x000045b1
    4894:	00004565 	.word	0x00004565

00004898 <send_nine>:

void send_nine(void) { // 1 00 111 0
    4898:	b510      	push	{r4, lr}
    send_preamble();
    489a:	4b07      	ldr	r3, [pc, #28]	; (48b8 <send_nine+0x20>)
    489c:	4798      	blx	r3
    bit_SET();
    489e:	4907      	ldr	r1, [pc, #28]	; (48bc <send_nine+0x24>)
    48a0:	4788      	blx	r1
    bit_CLR(); bit_CLR();
    48a2:	4807      	ldr	r0, [pc, #28]	; (48c0 <send_nine+0x28>)
    48a4:	4780      	blx	r0
    48a6:	4780      	blx	r0
    bit_SET(); bit_SET(); bit_SET();
    48a8:	4788      	blx	r1
    48aa:	4788      	blx	r1
    48ac:	4788      	blx	r1
    bit_CLR();
    48ae:	4780      	blx	r0
    common_end();
    48b0:	4b04      	ldr	r3, [pc, #16]	; (48c4 <send_nine+0x2c>)
}
    48b2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    common_end();
    48b6:	4718      	bx	r3
    48b8:	000045cd 	.word	0x000045cd
    48bc:	000045b1 	.word	0x000045b1
    48c0:	00004599 	.word	0x00004599
    48c4:	00004565 	.word	0x00004565

000048c8 <send_six>:

void send_six(void) { // 011 011 0
    48c8:	b510      	push	{r4, lr}
    send_preamble();
    48ca:	4b07      	ldr	r3, [pc, #28]	; (48e8 <send_six+0x20>)
    48cc:	4798      	blx	r3
    bit_CLR(); bit_SET(); bit_SET();
    48ce:	4807      	ldr	r0, [pc, #28]	; (48ec <send_six+0x24>)
    48d0:	4780      	blx	r0
    48d2:	4907      	ldr	r1, [pc, #28]	; (48f0 <send_six+0x28>)
    48d4:	4788      	blx	r1
    48d6:	4788      	blx	r1
    bit_CLR(); bit_SET(); bit_SET();
    48d8:	4780      	blx	r0
    48da:	4788      	blx	r1
    48dc:	4788      	blx	r1
    bit_CLR();
    48de:	4780      	blx	r0
    common_end();
    48e0:	4b04      	ldr	r3, [pc, #16]	; (48f4 <send_six+0x2c>)
}
    48e2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    common_end();
    48e6:	4718      	bx	r3
    48e8:	000045cd 	.word	0x000045cd
    48ec:	00004599 	.word	0x00004599
    48f0:	000045b1 	.word	0x000045b1
    48f4:	00004565 	.word	0x00004565

000048f8 <send_eight>:

void send_eight(void) { // 0001110 maybe
    48f8:	b510      	push	{r4, lr}
    send_preamble();
    48fa:	4b07      	ldr	r3, [pc, #28]	; (4918 <send_eight+0x20>)
    48fc:	4798      	blx	r3
    bit_CLR(); bit_CLR(); bit_CLR();
    48fe:	4907      	ldr	r1, [pc, #28]	; (491c <send_eight+0x24>)
    4900:	4788      	blx	r1
    4902:	4788      	blx	r1
    4904:	4788      	blx	r1
    bit_SET(); bit_SET(); bit_SET();
    4906:	4806      	ldr	r0, [pc, #24]	; (4920 <send_eight+0x28>)
    4908:	4780      	blx	r0
    490a:	4780      	blx	r0
    490c:	4780      	blx	r0
    bit_CLR();
    490e:	4788      	blx	r1
    common_end();
    4910:	4b04      	ldr	r3, [pc, #16]	; (4924 <send_eight+0x2c>)
}
    4912:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    common_end();
    4916:	4718      	bx	r3
    4918:	000045cd 	.word	0x000045cd
    491c:	00004599 	.word	0x00004599
    4920:	000045b1 	.word	0x000045b1
    4924:	00004565 	.word	0x00004565

00004928 <send_november>:

void send_november(void) { // zero one one one zero zero one
    4928:	b510      	push	{r4, lr}
    send_preamble();
    492a:	4b07      	ldr	r3, [pc, #28]	; (4948 <send_november+0x20>)
    492c:	4798      	blx	r3
    bit_CLR();
    492e:	4807      	ldr	r0, [pc, #28]	; (494c <send_november+0x24>)
    4930:	4780      	blx	r0
    bit_SET();
    4932:	4907      	ldr	r1, [pc, #28]	; (4950 <send_november+0x28>)
    4934:	4788      	blx	r1
    bit_SET();
    4936:	4788      	blx	r1
    bit_SET();
    4938:	4788      	blx	r1
    bit_CLR();
    493a:	4780      	blx	r0
    bit_CLR();
    493c:	4780      	blx	r0
    bit_SET();
    493e:	4788      	blx	r1
    common_end();
    4940:	4b04      	ldr	r3, [pc, #16]	; (4954 <send_november+0x2c>)
}
    4942:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    common_end();
    4946:	4718      	bx	r3
    4948:	000045cd 	.word	0x000045cd
    494c:	00004599 	.word	0x00004599
    4950:	000045b1 	.word	0x000045b1
    4954:	00004565 	.word	0x00004565

00004958 <send_romeo>:

void send_romeo(void) { // 0 1 00 101
    4958:	b510      	push	{r4, lr}
    send_preamble();
    495a:	4b07      	ldr	r3, [pc, #28]	; (4978 <send_romeo+0x20>)
    495c:	4798      	blx	r3
    bit_CLR();
    495e:	4907      	ldr	r1, [pc, #28]	; (497c <send_romeo+0x24>)
    4960:	4788      	blx	r1
    bit_SET();
    4962:	4807      	ldr	r0, [pc, #28]	; (4980 <send_romeo+0x28>)
    4964:	4780      	blx	r0
    bit_CLR();
    4966:	4788      	blx	r1
    bit_CLR();
    4968:	4788      	blx	r1
    bit_SET();
    496a:	4780      	blx	r0
    bit_CLR();
    496c:	4788      	blx	r1
    bit_SET();
    496e:	4780      	blx	r0
    common_end();
    4970:	4b04      	ldr	r3, [pc, #16]	; (4984 <send_romeo+0x2c>)
}
    4972:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    common_end();
    4976:	4718      	bx	r3
    4978:	000045cd 	.word	0x000045cd
    497c:	00004599 	.word	0x00004599
    4980:	000045b1 	.word	0x000045b1
    4984:	00004565 	.word	0x00004565

00004988 <send_four>:

void send_four(void) { // 0010110
    4988:	b510      	push	{r4, lr}
    send_preamble();
    498a:	4b07      	ldr	r3, [pc, #28]	; (49a8 <send_four+0x20>)
    498c:	4798      	blx	r3
    bit_CLR(); bit_CLR();
    498e:	4907      	ldr	r1, [pc, #28]	; (49ac <send_four+0x24>)
    4990:	4788      	blx	r1
    4992:	4788      	blx	r1
    bit_SET(); bit_CLR();
    4994:	4806      	ldr	r0, [pc, #24]	; (49b0 <send_four+0x28>)
    4996:	4780      	blx	r0
    4998:	4788      	blx	r1
    bit_SET(); bit_SET();
    499a:	4780      	blx	r0
    499c:	4780      	blx	r0
    bit_CLR();
    499e:	4788      	blx	r1
    common_end();
    49a0:	4b04      	ldr	r3, [pc, #16]	; (49b4 <send_four+0x2c>)
}
    49a2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    common_end();
    49a6:	4718      	bx	r3
    49a8:	000045cd 	.word	0x000045cd
    49ac:	00004599 	.word	0x00004599
    49b0:	000045b1 	.word	0x000045b1
    49b4:	00004565 	.word	0x00004565

000049b8 <send_tango>:

void send_tango(void) { // double zero then alternate out to the end
    49b8:	b510      	push	{r4, lr}
    send_preamble();
    49ba:	4b07      	ldr	r3, [pc, #28]	; (49d8 <send_tango+0x20>)
    49bc:	4798      	blx	r3

    bit_CLR();
    49be:	4907      	ldr	r1, [pc, #28]	; (49dc <send_tango+0x24>)
    49c0:	4788      	blx	r1
    bit_CLR();
    49c2:	4788      	blx	r1
    bit_SET();
    49c4:	4806      	ldr	r0, [pc, #24]	; (49e0 <send_tango+0x28>)
    49c6:	4780      	blx	r0
    bit_CLR();
    49c8:	4788      	blx	r1
    bit_SET();
    49ca:	4780      	blx	r0
    bit_CLR();
    49cc:	4788      	blx	r1
    bit_SET();
    49ce:	4780      	blx	r0
    common_end();
    49d0:	4b04      	ldr	r3, [pc, #16]	; (49e4 <send_tango+0x2c>)
}
    49d2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    common_end();
    49d6:	4718      	bx	r3
    49d8:	000045cd 	.word	0x000045cd
    49dc:	00004599 	.word	0x00004599
    49e0:	000045b1 	.word	0x000045b1
    49e4:	00004565 	.word	0x00004565

000049e8 <send_one>:

void send_one(void) { // send_one(); one triple zero one one zero : number_one
    49e8:	b510      	push	{r4, lr}

    send_preamble();
    49ea:	4b07      	ldr	r3, [pc, #28]	; (4a08 <send_one+0x20>)
    49ec:	4798      	blx	r3





    bit_SET();
    49ee:	4807      	ldr	r0, [pc, #28]	; (4a0c <send_one+0x24>)
    49f0:	4780      	blx	r0
    bit_CLR();
    49f2:	4907      	ldr	r1, [pc, #28]	; (4a10 <send_one+0x28>)
    49f4:	4788      	blx	r1
    bit_CLR();
    49f6:	4788      	blx	r1
    bit_CLR();
    49f8:	4788      	blx	r1
    bit_SET();
    49fa:	4780      	blx	r0
    bit_SET();
    49fc:	4780      	blx	r0
    bit_CLR();
    49fe:	4788      	blx	r1

    common_end();
    4a00:	4b04      	ldr	r3, [pc, #16]	; (4a14 <send_one+0x2c>)
}
    4a02:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    common_end();
    4a06:	4718      	bx	r3
    4a08:	000045cd 	.word	0x000045cd
    4a0c:	000045b1 	.word	0x000045b1
    4a10:	00004599 	.word	0x00004599
    4a14:	00004565 	.word	0x00004565

00004a18 <send_alpha>:

void send_alpha(void) { // one bit at beginning and end, four clear bits in between
    4a18:	b510      	push	{r4, lr}

    send_preamble();
    4a1a:	4b07      	ldr	r3, [pc, #28]	; (4a38 <send_alpha+0x20>)
    4a1c:	4798      	blx	r3

    bit_SET();
    4a1e:	4807      	ldr	r0, [pc, #28]	; (4a3c <send_alpha+0x24>)
    4a20:	4780      	blx	r0
    bit_CLR();
    4a22:	4907      	ldr	r1, [pc, #28]	; (4a40 <send_alpha+0x28>)
    4a24:	4788      	blx	r1
    bit_CLR();
    4a26:	4788      	blx	r1
    bit_CLR();
    4a28:	4788      	blx	r1
    bit_CLR();
    4a2a:	4788      	blx	r1
    bit_CLR();
    4a2c:	4788      	blx	r1
    bit_SET();
    4a2e:	4780      	blx	r0

    common_end();
    4a30:	4b04      	ldr	r3, [pc, #16]	; (4a44 <send_alpha+0x2c>)
}
    4a32:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    common_end();
    4a36:	4718      	bx	r3
    4a38:	000045cd 	.word	0x000045cd
    4a3c:	000045b1 	.word	0x000045b1
    4a40:	00004599 	.word	0x00004599
    4a44:	00004565 	.word	0x00004565

00004a48 <send_whiskey>:



void send_whiskey(void) { // three set bits and then alternating totaling five
    4a48:	b510      	push	{r4, lr}

    // preamble

    send_nothing(); // guard time
    4a4a:	4b09      	ldr	r3, [pc, #36]	; (4a70 <send_whiskey+0x28>)
    4a4c:	4798      	blx	r3
    pip_space(); // delay 26 uSec
    4a4e:	4b09      	ldr	r3, [pc, #36]	; (4a74 <send_whiskey+0x2c>)
    4a50:	4798      	blx	r3

    bit_CLR();
    4a52:	4809      	ldr	r0, [pc, #36]	; (4a78 <send_whiskey+0x30>)
    4a54:	4780      	blx	r0

    // preamble ends.


    // send 2^0 bit:
    bit_SET();
    4a56:	4909      	ldr	r1, [pc, #36]	; (4a7c <send_whiskey+0x34>)
    4a58:	4788      	blx	r1

    // send 2^1 bit:
    bit_SET();
    4a5a:	4788      	blx	r1

    // send 2^2 bit:
    bit_SET();
    4a5c:	4788      	blx	r1

    // send 2^3 bit:
    bit_CLR();
    4a5e:	4780      	blx	r0

    // send 2^4 bit:
    bit_SET();
    4a60:	4788      	blx	r1

    // send 2^5 bit:
    bit_CLR();
    4a62:	4780      	blx	r0

    // send 2^6 bit:
    bit_SET();
    4a64:	4788      	blx	r1

    common_end();
    4a66:	4b06      	ldr	r3, [pc, #24]	; (4a80 <send_whiskey+0x38>)
}
    4a68:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    common_end();
    4a6c:	4718      	bx	r3
    4a6e:	bf00      	nop
    4a70:	00004541 	.word	0x00004541
    4a74:	000044e1 	.word	0x000044e1
    4a78:	00004599 	.word	0x00004599
    4a7c:	000045b1 	.word	0x000045b1
    4a80:	00004565 	.word	0x00004565

00004a84 <send_seven>:


void send_seven(void) { // set set set clear set set
    4a84:	b510      	push	{r4, lr}

    // preamble

    send_nothing(); // guard time
    4a86:	4b09      	ldr	r3, [pc, #36]	; (4aac <send_seven+0x28>)
    4a88:	4798      	blx	r3
    pip_space(); // delay 26 uSec
    4a8a:	4b09      	ldr	r3, [pc, #36]	; (4ab0 <send_seven+0x2c>)
    4a8c:	4798      	blx	r3

    bit_CLR();
    4a8e:	4809      	ldr	r0, [pc, #36]	; (4ab4 <send_seven+0x30>)
    4a90:	4780      	blx	r0

    // preamble ends.


    // send 2^0 bit:
    bit_SET();
    4a92:	4909      	ldr	r1, [pc, #36]	; (4ab8 <send_seven+0x34>)
    4a94:	4788      	blx	r1

    // send 2^1 bit:
    bit_SET();
    4a96:	4788      	blx	r1

    // send 2^2 bit:
    bit_SET();
    4a98:	4788      	blx	r1

    // send 2^3 bit:
    bit_CLR();
    4a9a:	4780      	blx	r0

    // send 2^4 bit:
    bit_SET();
    4a9c:	4788      	blx	r1

    // send 2^5 bit:
    bit_SET();
    4a9e:	4788      	blx	r1

    // send 2^6 bit:
    bit_CLR();
    4aa0:	4780      	blx	r0

    common_end();
    4aa2:	4b06      	ldr	r3, [pc, #24]	; (4abc <send_seven+0x38>)
}
    4aa4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    common_end();
    4aa8:	4718      	bx	r3
    4aaa:	bf00      	nop
    4aac:	00004541 	.word	0x00004541
    4ab0:	000044e1 	.word	0x000044e1
    4ab4:	00004599 	.word	0x00004599
    4ab8:	000045b1 	.word	0x000045b1
    4abc:	00004565 	.word	0x00004565

00004ac0 <send_five>:



void send_five(void) { // set clear set clear set set is five
    4ac0:	b510      	push	{r4, lr}
    // preamble

    send_nothing(); // guard time
    4ac2:	4b09      	ldr	r3, [pc, #36]	; (4ae8 <send_five+0x28>)
    4ac4:	4798      	blx	r3
    pip_space(); // delay 26 uSec
    4ac6:	4b09      	ldr	r3, [pc, #36]	; (4aec <send_five+0x2c>)
    4ac8:	4798      	blx	r3

    bit_CLR();
    4aca:	4909      	ldr	r1, [pc, #36]	; (4af0 <send_five+0x30>)
    4acc:	4788      	blx	r1

    // preamble ends.


    // send 2^0 bit:
    bit_SET();
    4ace:	4809      	ldr	r0, [pc, #36]	; (4af4 <send_five+0x34>)
    4ad0:	4780      	blx	r0

    // send 2^1 bit:
    bit_CLR();
    4ad2:	4788      	blx	r1

    // send 2^2 bit:
    bit_SET();
    4ad4:	4780      	blx	r0

    // send 2^3 bit:
    bit_CLR();
    4ad6:	4788      	blx	r1

    // send 2^4 bit:
    bit_SET();
    4ad8:	4780      	blx	r0

    // send 2^5 bit:
    bit_SET();
    4ada:	4780      	blx	r0

    // send 2^6 bit:
    bit_CLR();
    4adc:	4788      	blx	r1

    // post-amble hi hi

    common_end();
    4ade:	4b06      	ldr	r3, [pc, #24]	; (4af8 <send_five+0x38>)
}
    4ae0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    common_end();
    4ae4:	4718      	bx	r3
    4ae6:	bf00      	nop
    4ae8:	00004541 	.word	0x00004541
    4aec:	000044e1 	.word	0x000044e1
    4af0:	00004599 	.word	0x00004599
    4af4:	000045b1 	.word	0x000045b1
    4af8:	00004565 	.word	0x00004565

00004afc <send_at_symb>:



void send_at_symb(void) { // send at symbol circle a
    4afc:	b510      	push	{r4, lr}
    // preamble

    send_nothing(); // guard time
    4afe:	4b0e      	ldr	r3, [pc, #56]	; (4b38 <send_at_symb+0x3c>)
    4b00:	4798      	blx	r3
    pip_space(); // delay 26 uSec
    4b02:	4a0e      	ldr	r2, [pc, #56]	; (4b3c <send_at_symb+0x40>)
    4b04:	4790      	blx	r2

    PORT->Group[1].OUTCLR.reg = (uint32_t)(1 << 16); // PB16 //  0 16 pinwrite
    4b06:	490e      	ldr	r1, [pc, #56]	; (4b40 <send_at_symb+0x44>)
    4b08:	f44f 3080 	mov.w	r0, #65536	; 0x10000
    4b0c:	f8c1 0094 	str.w	r0, [r1, #148]	; 0x94
    pip_space(); // delay 26 uSec
    4b10:	4790      	blx	r2
    // preamble ends.



    // send 2^0 bit:
    PORT->Group[1].OUTCLR.reg = (uint32_t)(1 << 16); // PB16, clr
    4b12:	f8c1 0094 	str.w	r0, [r1, #148]	; 0x94
    pip_space(); // delay 26 uSec
    4b16:	4790      	blx	r2

    // send 2^1 bit:
    pip_space(); // delay 26 uSec
    4b18:	4790      	blx	r2

    // send 2^2 bit:
    pip_space(); // delay 26 uSec
    4b1a:	4790      	blx	r2

    // send 2^3 bit:
    pip_space(); // delay 26 uSec
    4b1c:	4790      	blx	r2

    // send 2^4 bit:
    pip_space(); // delay 26 uSec
    4b1e:	4790      	blx	r2

    // send 2^5 bit:
    pip_space(); // delay 26 uSec
    4b20:	4790      	blx	r2

    // send 2^6 bit:
    PORT->Group[1].OUTSET.reg |= (uint32_t)(1 << 16); // PB16 //  1 16 pinwrite
    4b22:	f8d1 3098 	ldr.w	r3, [r1, #152]	; 0x98
    4b26:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    4b2a:	f8c1 3098 	str.w	r3, [r1, #152]	; 0x98
    pip_space(); // delay 26 uSec
    4b2e:	4790      	blx	r2

    // post-amble hi hi

    common_end();
    4b30:	4b04      	ldr	r3, [pc, #16]	; (4b44 <send_at_symb+0x48>)
}
    4b32:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    common_end();
    4b36:	4718      	bx	r3
    4b38:	00004541 	.word	0x00004541
    4b3c:	000044e1 	.word	0x000044e1
    4b40:	41008000 	.word	0x41008000
    4b44:	00004565 	.word	0x00004565

00004b48 <send_quebec>:


void send_quebec(void) { // send upper case Q
    4b48:	b510      	push	{r4, lr}
    // preamble
    // comment

    send_nothing(); // guard time
    4b4a:	4b15      	ldr	r3, [pc, #84]	; (4ba0 <send_quebec+0x58>)
    4b4c:	4798      	blx	r3

    pip_space(); // delay 26 uSec
    4b4e:	4a15      	ldr	r2, [pc, #84]	; (4ba4 <send_quebec+0x5c>)
    4b50:	4790      	blx	r2
    // PORT->Group[0].OUTTGL.reg = (uint32_t)(1 << 16); // PA16 // D11 toggle

    PORT->Group[1].OUTCLR.reg = (uint32_t)(1 << 16); // PB16 //  0 16 pinwrite
    4b52:	4915      	ldr	r1, [pc, #84]	; (4ba8 <send_quebec+0x60>)
    4b54:	f44f 3080 	mov.w	r0, #65536	; 0x10000
    4b58:	f8c1 0094 	str.w	r0, [r1, #148]	; 0x94
    pip_space(); // delay 26 uSec
    4b5c:	4790      	blx	r2
    // preamble ends.



    // send 2^0 bit:
    PORT->Group[1].OUTSET.reg |= (uint32_t)(1 << 16); // PB16 //  1 16 pinwrite
    4b5e:	f8d1 3098 	ldr.w	r3, [r1, #152]	; 0x98
    4b62:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    4b66:	f8c1 3098 	str.w	r3, [r1, #152]	; 0x98
    pip_space(); // delay 26 uSec
    4b6a:	4790      	blx	r2



    // send 2^1 bit:
    PORT->Group[1].OUTCLR.reg = (uint32_t)(1 << 16); // PB16, clr
    4b6c:	f8c1 0094 	str.w	r0, [r1, #148]	; 0x94
    pip_space(); // delay 26 uSec
    4b70:	4790      	blx	r2

    // send 2^2 bit:
    pip_space(); // delay 26 uSec
    4b72:	4790      	blx	r2

    // send 2^3 bit:
    pip_space(); // delay 26 uSec
    4b74:	4790      	blx	r2

    // send 2^4 bit:
    PORT->Group[1].OUTSET.reg |= (uint32_t)(1 << 16); // PB16 //  1 16 pinwrite
    4b76:	f8d1 3098 	ldr.w	r3, [r1, #152]	; 0x98
    4b7a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    4b7e:	f8c1 3098 	str.w	r3, [r1, #152]	; 0x98
    pip_space(); // delay 26 uSec
    4b82:	4790      	blx	r2

    // send 2^5 bit:
    // PORT->Group[1].OUTSET.reg |= (uint32_t)(1 << 16); // PB16 //  1 16 pinwrite

    PORT->Group[1].OUTCLR.reg = (uint32_t)(1 << 16); // PB16 //  0 16 pinwrite
    4b84:	f8c1 0094 	str.w	r0, [r1, #148]	; 0x94
    // PORT->Group[1].OUTCLR.reg = (uint32_t)(1 << 16); // PB16 //  0 16 pinwrite
    pip_space(); // delay 26 uSec
    4b88:	4790      	blx	r2

    // send 2^6 bit:

    PORT->Group[1].OUTSET.reg |= (uint32_t)(1 << 16); // PB16 //  1 16 pinwrite
    4b8a:	f8d1 3098 	ldr.w	r3, [r1, #152]	; 0x98
    4b8e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    4b92:	f8c1 3098 	str.w	r3, [r1, #152]	; 0x98
    pip_space(); // delay 26 uSec
    4b96:	4790      	blx	r2

    // post-amble hi hi
    common_end();
    4b98:	4b04      	ldr	r3, [pc, #16]	; (4bac <send_quebec+0x64>)
}
    4b9a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    common_end();
    4b9e:	4718      	bx	r3
    4ba0:	00004541 	.word	0x00004541
    4ba4:	000044e1 	.word	0x000044e1
    4ba8:	41008000 	.word	0x41008000
    4bac:	00004565 	.word	0x00004565

00004bb0 <printty_zero>:
        send_at_symb(); send_gapspace();
        send_at_symb(); send_gapspace();
 // }
}

void printty_zero(void) {
    4bb0:	b510      	push	{r4, lr}
    send_zero();
    4bb2:	4b03      	ldr	r3, [pc, #12]	; (4bc0 <printty_zero+0x10>)
    4bb4:	4798      	blx	r3
    send_gapspace();
    4bb6:	4b03      	ldr	r3, [pc, #12]	; (4bc4 <printty_zero+0x14>)
}
    4bb8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    send_gapspace();
    4bbc:	4718      	bx	r3
    4bbe:	bf00      	nop
    4bc0:	00004869 	.word	0x00004869
    4bc4:	00004851 	.word	0x00004851

00004bc8 <printty_one>:
void printty_one(void) {
    4bc8:	b510      	push	{r4, lr}
    send_one();
    4bca:	4b03      	ldr	r3, [pc, #12]	; (4bd8 <printty_one+0x10>)
    4bcc:	4798      	blx	r3
    send_gapspace();
    4bce:	4b03      	ldr	r3, [pc, #12]	; (4bdc <printty_one+0x14>)
}
    4bd0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    send_gapspace();
    4bd4:	4718      	bx	r3
    4bd6:	bf00      	nop
    4bd8:	000049e9 	.word	0x000049e9
    4bdc:	00004851 	.word	0x00004851

00004be0 <showbits>:


void showbits(unsigned int x) {
    4be0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    for(int i = 0; i < 8; i++) {
       (x & (1u << i)) ? printty_zero() : printty_one();
    4be4:	4e09      	ldr	r6, [pc, #36]	; (4c0c <showbits+0x2c>)
    4be6:	4f0a      	ldr	r7, [pc, #40]	; (4c10 <showbits+0x30>)
void showbits(unsigned int x) {
    4be8:	4605      	mov	r5, r0
    for(int i = 0; i < 8; i++) {
    4bea:	2400      	movs	r4, #0
       (x & (1u << i)) ? printty_zero() : printty_one();
    4bec:	fa25 f304 	lsr.w	r3, r5, r4
    4bf0:	07db      	lsls	r3, r3, #31
    4bf2:	d509      	bpl.n	4c08 <showbits+0x28>
    4bf4:	47b8      	blx	r7
    for(int i = 0; i < 8; i++) {
    4bf6:	3401      	adds	r4, #1
    4bf8:	2c08      	cmp	r4, #8
    4bfa:	d1f7      	bne.n	4bec <showbits+0xc>
    }
    send_crlf(); send_gapspace();
    4bfc:	4b05      	ldr	r3, [pc, #20]	; (4c14 <showbits+0x34>)
    4bfe:	4798      	blx	r3
    4c00:	4b05      	ldr	r3, [pc, #20]	; (4c18 <showbits+0x38>)
}
    4c02:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    send_crlf(); send_gapspace();
    4c06:	4718      	bx	r3
       (x & (1u << i)) ? printty_zero() : printty_one();
    4c08:	47b0      	blx	r6
    4c0a:	e7f4      	b.n	4bf6 <showbits+0x16>
    4c0c:	00004bc9 	.word	0x00004bc9
    4c10:	00004bb1 	.word	0x00004bb1
    4c14:	000047cd 	.word	0x000047cd
    4c18:	00004851 	.word	0x00004851

00004c1c <blitwbits>:


void blitwbits(unsigned int x) {
    4c1c:	b570      	push	{r4, r5, r6, lr}
    send_preamble();
    4c1e:	4b09      	ldr	r3, [pc, #36]	; (4c44 <blitwbits+0x28>)
    for(int i = 0; i < 7; i++) {
       (x & (1u << i)) ?  bit_SET() : bit_CLR();
    4c20:	4c09      	ldr	r4, [pc, #36]	; (4c48 <blitwbits+0x2c>)
    4c22:	4d0a      	ldr	r5, [pc, #40]	; (4c4c <blitwbits+0x30>)
    send_preamble();
    4c24:	4798      	blx	r3
    for(int i = 0; i < 7; i++) {
    4c26:	2100      	movs	r1, #0
       (x & (1u << i)) ?  bit_SET() : bit_CLR();
    4c28:	fa20 f301 	lsr.w	r3, r0, r1
    4c2c:	07db      	lsls	r3, r3, #31
    4c2e:	d507      	bpl.n	4c40 <blitwbits+0x24>
    4c30:	47a8      	blx	r5
    for(int i = 0; i < 7; i++) {
    4c32:	3101      	adds	r1, #1
    4c34:	2907      	cmp	r1, #7
    4c36:	d1f7      	bne.n	4c28 <blitwbits+0xc>
    }
    common_end();
    4c38:	4b05      	ldr	r3, [pc, #20]	; (4c50 <blitwbits+0x34>)
}
    4c3a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    common_end();
    4c3e:	4718      	bx	r3
       (x & (1u << i)) ?  bit_SET() : bit_CLR();
    4c40:	47a0      	blx	r4
    4c42:	e7f6      	b.n	4c32 <blitwbits+0x16>
    4c44:	000045cd 	.word	0x000045cd
    4c48:	00004599 	.word	0x00004599
    4c4c:	000045b1 	.word	0x000045b1
    4c50:	00004565 	.word	0x00004565

00004c54 <print_mar>:

void print_mar(void) {
    4c54:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    for (int j = 8; j>0; j--) { // send the text eight times
        send_crlf(); send_gapspace();
    4c58:	f8df 9080 	ldr.w	r9, [pc, #128]	; 4cdc <print_mar+0x88>
    4c5c:	4d1d      	ldr	r5, [pc, #116]	; (4cd4 <print_mar+0x80>)
void print_mar(void) {
    4c5e:	f04f 0808 	mov.w	r8, #8
    4c62:	464e      	mov	r6, r9
        send_crlf(); send_gapspace();
    4c64:	47c8      	blx	r9
    4c66:	47a8      	blx	r5
        for (uint8_t findix = 32; findix < 127; findix++) {
            blitwbits(findix);
    4c68:	4c1b      	ldr	r4, [pc, #108]	; (4cd8 <print_mar+0x84>)
        send_crlf(); send_gapspace();
    4c6a:	2720      	movs	r7, #32
            blitwbits(findix);
    4c6c:	4638      	mov	r0, r7
    4c6e:	3701      	adds	r7, #1
    4c70:	47a0      	blx	r4
        for (uint8_t findix = 32; findix < 127; findix++) {
    4c72:	2f7f      	cmp	r7, #127	; 0x7f
    4c74:	d1fa      	bne.n	4c6c <print_mar+0x18>
        }
    send_crlf(); send_gapspace();
    4c76:	47b0      	blx	r6
    4c78:	47a8      	blx	r5
    for (int j = 8; j>0; j--) { // send the text eight times
    4c7a:	f1b8 0801 	subs.w	r8, r8, #1
    4c7e:	d1f1      	bne.n	4c64 <print_mar+0x10>
    }

    uint8_t letr = 'a';

    send_crlf(); send_gapspace();
    4c80:	47b0      	blx	r6
    4c82:	47a8      	blx	r5
    send_crlf(); send_gapspace();
    4c84:	47b0      	blx	r6
    4c86:	47a8      	blx	r5
    letr = ' '; blitwbits(letr);
    4c88:	2020      	movs	r0, #32
    4c8a:	47a0      	blx	r4
    letr = ' '; blitwbits(letr);
    4c8c:	2020      	movs	r0, #32
    4c8e:	47a0      	blx	r4
    letr = 'a'; blitwbits(letr);
    4c90:	2061      	movs	r0, #97	; 0x61
    4c92:	47a0      	blx	r4
    letr = 'r'; blitwbits(letr);
    4c94:	2072      	movs	r0, #114	; 0x72
    4c96:	47a0      	blx	r4
    letr = 'e'; blitwbits(letr);
    4c98:	2065      	movs	r0, #101	; 0x65
    4c9a:	47a0      	blx	r4
    letr = ' '; blitwbits(letr);
    4c9c:	2020      	movs	r0, #32
    4c9e:	47a0      	blx	r4
    letr = 'y'; blitwbits(letr);
    4ca0:	2079      	movs	r0, #121	; 0x79
    4ca2:	47a0      	blx	r4
    letr = 'o'; blitwbits(letr);
    4ca4:	206f      	movs	r0, #111	; 0x6f
    4ca6:	47a0      	blx	r4
    letr = 'u'; blitwbits(letr);
    4ca8:	2075      	movs	r0, #117	; 0x75
    4caa:	47a0      	blx	r4
    letr = ' '; blitwbits(letr);
    4cac:	2020      	movs	r0, #32
    4cae:	47a0      	blx	r4
    letr = 'r'; blitwbits(letr);
    4cb0:	2072      	movs	r0, #114	; 0x72
    4cb2:	47a0      	blx	r4
    letr = 'e'; blitwbits(letr);
    4cb4:	2065      	movs	r0, #101	; 0x65
    4cb6:	47a0      	blx	r4
    letr = 'a'; blitwbits(letr);
    4cb8:	2061      	movs	r0, #97	; 0x61
    4cba:	47a0      	blx	r4
    letr = 'd'; blitwbits(letr);
    4cbc:	2064      	movs	r0, #100	; 0x64
    4cbe:	47a0      	blx	r4
    letr = 'y'; blitwbits(letr);
    4cc0:	2079      	movs	r0, #121	; 0x79
    4cc2:	47a0      	blx	r4
    letr = '?'; blitwbits(letr);
    4cc4:	203f      	movs	r0, #63	; 0x3f
    4cc6:	47a0      	blx	r4
    send_crlf(); send_gapspace();
    4cc8:	47b0      	blx	r6
    4cca:	462b      	mov	r3, r5
}
    4ccc:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    send_crlf(); send_gapspace();
    4cd0:	4718      	bx	r3
    4cd2:	bf00      	nop
    4cd4:	00004851 	.word	0x00004851
    4cd8:	00004c1d 	.word	0x00004c1d
    4cdc:	000047cd 	.word	0x000047cd

00004ce0 <do_this>:
        printp();
    }
    // common_end();
}

void do_this(void) {
    4ce0:	b570      	push	{r4, r5, r6, lr}
    send_crlf(); send_gapspace();
    4ce2:	4b07      	ldr	r3, [pc, #28]	; (4d00 <do_this+0x20>)
    for (int i=0; i<10; i++) {
        hold = 80 + i;
    4ce4:	4e07      	ldr	r6, [pc, #28]	; (4d04 <do_this+0x24>)
        // do_that();
        showbits(hold);
    4ce6:	4d08      	ldr	r5, [pc, #32]	; (4d08 <do_this+0x28>)
    send_crlf(); send_gapspace();
    4ce8:	4798      	blx	r3
    4cea:	4b08      	ldr	r3, [pc, #32]	; (4d0c <do_this+0x2c>)
    4cec:	4798      	blx	r3
    4cee:	2450      	movs	r4, #80	; 0x50
        hold = 80 + i;
    4cf0:	7174      	strb	r4, [r6, #5]
        showbits(hold);
    4cf2:	4620      	mov	r0, r4
    4cf4:	3401      	adds	r4, #1
    4cf6:	47a8      	blx	r5
    for (int i=0; i<10; i++) {
    4cf8:	2c5a      	cmp	r4, #90	; 0x5a
    4cfa:	d1f9      	bne.n	4cf0 <do_this+0x10>
    }
}
    4cfc:	bd70      	pop	{r4, r5, r6, pc}
    4cfe:	bf00      	nop
    4d00:	000047cd 	.word	0x000047cd
    4d04:	20000004 	.word	0x20000004
    4d08:	00004be1 	.word	0x00004be1
    4d0c:	00004851 	.word	0x00004851

00004d10 <main>:
// ###bookmark
// ###bookmark


int main(void) {
    4d10:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    // Nice triple, 8 MHZ:
    SystemCoreClockUpdate();
    4d12:	4b3b      	ldr	r3, [pc, #236]	; (4e00 <main+0xf0>)
    4d14:	4798      	blx	r3
    SystemInit();
    4d16:	4b3b      	ldr	r3, [pc, #236]	; (4e04 <main+0xf4>)
    4d18:	4798      	blx	r3
    pins_setup(); // D11 in OUTPUT mode
    4d1a:	4b3b      	ldr	r3, [pc, #236]	; (4e08 <main+0xf8>)
    4d1c:	4798      	blx	r3

    ClockInit120();
    4d1e:	4b3b      	ldr	r3, [pc, #236]	; (4e0c <main+0xfc>)
    4d20:	4798      	blx	r3
    setup_PA14_as_GCLK_IO();
    4d22:	4b3b      	ldr	r3, [pc, #236]	; (4e10 <main+0x100>)
    4d24:	4798      	blx	r3
    // omit:
    // SysTick_Config(4000);

    stuffit = 43;
    4d26:	4b3b      	ldr	r3, [pc, #236]	; (4e14 <main+0x104>)
    4d28:	222b      	movs	r2, #43	; 0x2b
    4d2a:	719a      	strb	r2, [r3, #6]
    send_crlf(); send_gapspace();
    4d2c:	4b3a      	ldr	r3, [pc, #232]	; (4e18 <main+0x108>)
    4d2e:	4798      	blx	r3
    4d30:	4b3a      	ldr	r3, [pc, #232]	; (4e1c <main+0x10c>)
    4d32:	4798      	blx	r3
    print_mar();
    4d34:	4b3a      	ldr	r3, [pc, #232]	; (4e20 <main+0x110>)
    4d36:	4798      	blx	r3

    do_this();
    4d38:	4b3a      	ldr	r3, [pc, #232]	; (4e24 <main+0x114>)
    4d3a:	4798      	blx	r3

    for (volatile int k=21044; k>0; k--){
    4d3c:	f245 2334 	movw	r3, #21044	; 0x5234
    4d40:	9300      	str	r3, [sp, #0]
    4d42:	9b00      	ldr	r3, [sp, #0]
    4d44:	2b00      	cmp	r3, #0
    4d46:	dc54      	bgt.n	4df2 <main+0xe2>
    }

    for (int j=44444; j>0; j--){
        // send_skeleton(); // compiler warning

                   send_gapp();
    4d48:	4c37      	ldr	r4, [pc, #220]	; (4e28 <main+0x118>)

        send_whiskey();        send_gapp();
    4d4a:	4f38      	ldr	r7, [pc, #224]	; (4e2c <main+0x11c>)
        send_tango();          send_gapp();
    4d4c:	4e38      	ldr	r6, [pc, #224]	; (4e30 <main+0x120>)
    4d4e:	f64a 559c 	movw	r5, #44444	; 0xad9c
                   send_gapp();
    4d52:	47a0      	blx	r4
        send_whiskey();        send_gapp();
    4d54:	47b8      	blx	r7
    4d56:	47a0      	blx	r4
        send_tango();          send_gapp();
    4d58:	47b0      	blx	r6
    4d5a:	47a0      	blx	r4
        send_quebec();         send_gapp();
    4d5c:	4b35      	ldr	r3, [pc, #212]	; (4e34 <main+0x124>)
    4d5e:	4798      	blx	r3
    4d60:	47a0      	blx	r4
        send_romeo();          send_gapp();
    4d62:	4b35      	ldr	r3, [pc, #212]	; (4e38 <main+0x128>)
    4d64:	4798      	blx	r3
    4d66:	47a0      	blx	r4
        send_november();       send_gapp();
    4d68:	4b34      	ldr	r3, [pc, #208]	; (4e3c <main+0x12c>)
    4d6a:	4798      	blx	r3
    4d6c:	47a0      	blx	r4

        send_golf();           send_gapp();
    4d6e:	4b34      	ldr	r3, [pc, #208]	; (4e40 <main+0x130>)
    4d70:	4798      	blx	r3
    4d72:	47a0      	blx	r4
        send_foxtrot();        send_gapp();
    4d74:	4b33      	ldr	r3, [pc, #204]	; (4e44 <main+0x134>)
    4d76:	4798      	blx	r3
    4d78:	47a0      	blx	r4
        send_echo();           send_gapp();
    4d7a:	4b33      	ldr	r3, [pc, #204]	; (4e48 <main+0x138>)
    4d7c:	4798      	blx	r3
    4d7e:	47a0      	blx	r4
        send_delta();          send_gapp();
    4d80:	4b32      	ldr	r3, [pc, #200]	; (4e4c <main+0x13c>)
    4d82:	4798      	blx	r3
    4d84:	47a0      	blx	r4
        send_charley();        send_gapp();
    4d86:	4b32      	ldr	r3, [pc, #200]	; (4e50 <main+0x140>)
    4d88:	4798      	blx	r3
    4d8a:	47a0      	blx	r4
        send_bravo();          send_gapp();
    4d8c:	4b31      	ldr	r3, [pc, #196]	; (4e54 <main+0x144>)
    4d8e:	4798      	blx	r3
    4d90:	47a0      	blx	r4
        send_alpha();          send_gapp();
    4d92:	4b31      	ldr	r3, [pc, #196]	; (4e58 <main+0x148>)
    4d94:	4798      	blx	r3
    4d96:	47a0      	blx	r4

        send_zero();           send_gapp();
    4d98:	4b30      	ldr	r3, [pc, #192]	; (4e5c <main+0x14c>)
    4d9a:	4798      	blx	r3
    4d9c:	47a0      	blx	r4
        send_nine();           send_gapp();
    4d9e:	4b30      	ldr	r3, [pc, #192]	; (4e60 <main+0x150>)
    4da0:	4798      	blx	r3
    4da2:	47a0      	blx	r4
        send_eight();          send_gapp();
    4da4:	4b2f      	ldr	r3, [pc, #188]	; (4e64 <main+0x154>)
    4da6:	4798      	blx	r3
    4da8:	47a0      	blx	r4
        send_seven();          send_gapp();
    4daa:	4b2f      	ldr	r3, [pc, #188]	; (4e68 <main+0x158>)
    4dac:	4798      	blx	r3
    4dae:	47a0      	blx	r4
        send_six();            send_gapp();
    4db0:	4b2e      	ldr	r3, [pc, #184]	; (4e6c <main+0x15c>)
    4db2:	4798      	blx	r3
    4db4:	47a0      	blx	r4
        send_five();           send_gapp();
    4db6:	4b2e      	ldr	r3, [pc, #184]	; (4e70 <main+0x160>)
    4db8:	4798      	blx	r3
    4dba:	47a0      	blx	r4
        send_four();           send_gapp();
    4dbc:	4b2d      	ldr	r3, [pc, #180]	; (4e74 <main+0x164>)
    4dbe:	4798      	blx	r3
    4dc0:	47a0      	blx	r4
        send_three();          send_gapp();
    4dc2:	4b2d      	ldr	r3, [pc, #180]	; (4e78 <main+0x168>)
    4dc4:	4798      	blx	r3
    4dc6:	47a0      	blx	r4
        send_two();            send_gapp();
    4dc8:	4b2c      	ldr	r3, [pc, #176]	; (4e7c <main+0x16c>)
    4dca:	4798      	blx	r3
    4dcc:	47a0      	blx	r4
        send_one();            send_gapp();
    4dce:	4b2c      	ldr	r3, [pc, #176]	; (4e80 <main+0x170>)
    4dd0:	4798      	blx	r3
    4dd2:	47a0      	blx	r4

        send_at_symb();        send_gapp();
    4dd4:	4b2b      	ldr	r3, [pc, #172]	; (4e84 <main+0x174>)
    4dd6:	4798      	blx	r3
    4dd8:	47a0      	blx	r4
    for (int j=44444; j>0; j--){
    4dda:	3d01      	subs	r5, #1
    4ddc:	d1b9      	bne.n	4d52 <main+0x42>
// 26 uSec duration, per, or thereabouts).

    while (1) {
        for (volatile int j = SECU; j>0; j--) {
        }
        PORT->Group[0].OUTTGL.reg = (uint32_t)(1 << 21); // PA21 // D11 toggle
    4dde:	4a2a      	ldr	r2, [pc, #168]	; (4e88 <main+0x178>)
        for (volatile int j = SECU; j>0; j--) {
    4de0:	208d      	movs	r0, #141	; 0x8d
        PORT->Group[0].OUTTGL.reg = (uint32_t)(1 << 21); // PA21 // D11 toggle
    4de2:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
        for (volatile int j = SECU; j>0; j--) {
    4de6:	9001      	str	r0, [sp, #4]
    4de8:	9b01      	ldr	r3, [sp, #4]
    4dea:	2b00      	cmp	r3, #0
    4dec:	dc04      	bgt.n	4df8 <main+0xe8>
        PORT->Group[0].OUTTGL.reg = (uint32_t)(1 << 21); // PA21 // D11 toggle
    4dee:	61d1      	str	r1, [r2, #28]
        for (volatile int j = SECU; j>0; j--) {
    4df0:	e7f9      	b.n	4de6 <main+0xd6>
    for (volatile int k=21044; k>0; k--){
    4df2:	9b00      	ldr	r3, [sp, #0]
    4df4:	3b01      	subs	r3, #1
    4df6:	e7a3      	b.n	4d40 <main+0x30>
        for (volatile int j = SECU; j>0; j--) {
    4df8:	9b01      	ldr	r3, [sp, #4]
    4dfa:	3b01      	subs	r3, #1
    4dfc:	9301      	str	r3, [sp, #4]
    4dfe:	e7f3      	b.n	4de8 <main+0xd8>
    4e00:	000042ed 	.word	0x000042ed
    4e04:	000042dd 	.word	0x000042dd
    4e08:	000043d1 	.word	0x000043d1
    4e0c:	000043ed 	.word	0x000043ed
    4e10:	000044a9 	.word	0x000044a9
    4e14:	20000004 	.word	0x20000004
    4e18:	000047cd 	.word	0x000047cd
    4e1c:	00004851 	.word	0x00004851
    4e20:	00004c55 	.word	0x00004c55
    4e24:	00004ce1 	.word	0x00004ce1
    4e28:	00004839 	.word	0x00004839
    4e2c:	00004a49 	.word	0x00004a49
    4e30:	000049b9 	.word	0x000049b9
    4e34:	00004b49 	.word	0x00004b49
    4e38:	00004959 	.word	0x00004959
    4e3c:	00004929 	.word	0x00004929
    4e40:	000046dd 	.word	0x000046dd
    4e44:	0000461d 	.word	0x0000461d
    4e48:	0000467d 	.word	0x0000467d
    4e4c:	0000464d 	.word	0x0000464d
    4e50:	000046ad 	.word	0x000046ad
    4e54:	000045ed 	.word	0x000045ed
    4e58:	00004a19 	.word	0x00004a19
    4e5c:	00004869 	.word	0x00004869
    4e60:	00004899 	.word	0x00004899
    4e64:	000048f9 	.word	0x000048f9
    4e68:	00004a85 	.word	0x00004a85
    4e6c:	000048c9 	.word	0x000048c9
    4e70:	00004ac1 	.word	0x00004ac1
    4e74:	00004989 	.word	0x00004989
    4e78:	0000470d 	.word	0x0000470d
    4e7c:	0000473d 	.word	0x0000473d
    4e80:	000049e9 	.word	0x000049e9
    4e84:	00004afd 	.word	0x00004afd
    4e88:	41008000 	.word	0x41008000

00004e8c <__libc_init_array>:
    4e8c:	b570      	push	{r4, r5, r6, lr}
    4e8e:	4e0d      	ldr	r6, [pc, #52]	; (4ec4 <__libc_init_array+0x38>)
    4e90:	4c0d      	ldr	r4, [pc, #52]	; (4ec8 <__libc_init_array+0x3c>)
    4e92:	1ba4      	subs	r4, r4, r6
    4e94:	10a4      	asrs	r4, r4, #2
    4e96:	2500      	movs	r5, #0
    4e98:	42a5      	cmp	r5, r4
    4e9a:	d109      	bne.n	4eb0 <__libc_init_array+0x24>
    4e9c:	4e0b      	ldr	r6, [pc, #44]	; (4ecc <__libc_init_array+0x40>)
    4e9e:	4c0c      	ldr	r4, [pc, #48]	; (4ed0 <__libc_init_array+0x44>)
    4ea0:	f000 f818 	bl	4ed4 <_init>
    4ea4:	1ba4      	subs	r4, r4, r6
    4ea6:	10a4      	asrs	r4, r4, #2
    4ea8:	2500      	movs	r5, #0
    4eaa:	42a5      	cmp	r5, r4
    4eac:	d105      	bne.n	4eba <__libc_init_array+0x2e>
    4eae:	bd70      	pop	{r4, r5, r6, pc}
    4eb0:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
    4eb4:	4798      	blx	r3
    4eb6:	3501      	adds	r5, #1
    4eb8:	e7ee      	b.n	4e98 <__libc_init_array+0xc>
    4eba:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
    4ebe:	4798      	blx	r3
    4ec0:	3501      	adds	r5, #1
    4ec2:	e7f2      	b.n	4eaa <__libc_init_array+0x1e>
    4ec4:	00004ee0 	.word	0x00004ee0
    4ec8:	00004ee0 	.word	0x00004ee0
    4ecc:	00004ee0 	.word	0x00004ee0
    4ed0:	00004ee4 	.word	0x00004ee4

00004ed4 <_init>:
    4ed4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4ed6:	bf00      	nop
    4ed8:	bcf8      	pop	{r3, r4, r5, r6, r7}
    4eda:	bc08      	pop	{r3}
    4edc:	469e      	mov	lr, r3
    4ede:	4770      	bx	lr

00004ee0 <__init_array_start>:
    4ee0:	00004289 	.word	0x00004289

00004ee4 <_fini>:
    4ee4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4ee6:	bf00      	nop
    4ee8:	bcf8      	pop	{r3, r4, r5, r6, r7}
    4eea:	bc08      	pop	{r3}
    4eec:	469e      	mov	lr, r3
    4eee:	4770      	bx	lr

00004ef0 <__fini_array_start>:
    4ef0:	00004265 	.word	0x00004265
